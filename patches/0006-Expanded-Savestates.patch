From 316016ed3c594b0aedf10201e2cd26196fe880ec Mon Sep 17 00:00:00 2001
From: Zakk <zakk@rsdio.com>
Date: Sun, 19 Feb 2023 07:14:11 -0500
Subject: [PATCH 6/6] 0006

---
 cfg.cpp     |   3 ++
 cfg.h       |   3 ++
 cfg.h.orig  | 116 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 input.cpp   |  39 ++++++++++++++++--
 input.h     |   1 +
 menu.cpp    |  92 +++++++++++++++++++++++++++++++++++++++++
 menu.h      |   1 +
 user_io.cpp |  96 +++++++++++++++++++++++++++++++++++++++++--
 user_io.h   |  10 +++++
 9 files changed, 354 insertions(+), 7 deletions(-)
 create mode 100644 cfg.h.orig

diff --git a/cfg.cpp b/cfg.cpp
index 08e9ab0..454ead4 100644
--- a/cfg.cpp
+++ b/cfg.cpp
@@ -120,6 +120,9 @@ static const ini_var_t ini_vars[] =
 	{ "HDR_AVG_NITS", (void*)(&(cfg.hdr_avg_nits)), UINT16, 100, 10000},
 	{ "VGA_MODE", (void*)(&(cfg.vga_mode)), STRING, 0, sizeof(cfg.vga_mode) - 1 },
 	{ "NTSC_MODE", (void *)(&(cfg.ntsc_mode)), UINT8, 0, 2},
+	{ "SS_LOAD_BIT", (void *)(&(cfg.ss_load_bit)), STRING, 0, sizeof(cfg.ss_load_bit) - 1},
+  	{ "SS_SAVE_BIT", (void *)(&(cfg.ss_save_bit)), STRING, 0, sizeof(cfg.ss_save_bit) - 1},
+  	{ "SS_CURRENT_SLOT", (void *)(&(cfg.ss_current_slot)), STRING, 0, sizeof(cfg.ss_current_slot) - 1},
 };
 
 static const int nvars = (int)(sizeof(ini_vars) / sizeof(ini_var_t));
diff --git a/cfg.h b/cfg.h
index 689cfb6..427a1bc 100644
--- a/cfg.h
+++ b/cfg.h
@@ -92,6 +92,9 @@ typedef struct {
 	char vga_mode[16];
 	char vga_mode_int;
 	char ntsc_mode;
+	char ss_load_bit[8];
+  	char ss_save_bit[8];
+  	char ss_current_slot[15];
 } cfg_t;
 
 extern cfg_t cfg;
diff --git a/cfg.h.orig b/cfg.h.orig
new file mode 100644
index 0000000..689cfb6
--- /dev/null
+++ b/cfg.h.orig
@@ -0,0 +1,116 @@
+// cfg.h
+// 2015, rok.krajnc@gmail.com
+// 2017+, Sorgelig
+
+#ifndef __CFG_H__
+#define __CFG_H__
+
+#include <inttypes.h>
+
+//// type definitions ////
+typedef struct {
+	uint8_t  disable_nvram;
+	uint32_t keyrah_mode;
+	uint8_t forced_scandoubler;
+	uint8_t key_menu_as_rgui;
+	uint8_t reset_combo;
+	uint8_t csync;
+	uint8_t vga_scaler;
+	uint8_t vga_sog;
+	uint8_t hdmi_audio_96k;
+	uint8_t dvi_mode;
+	uint8_t hdmi_limited;
+	uint8_t direct_video;
+	uint8_t video_info;
+	float refresh_min;
+	float refresh_max;
+	uint8_t controller_info;
+	uint8_t vsync_adjust;
+	uint8_t kbd_nomouse;
+	uint8_t mouse_throttle;
+	uint8_t bootscreen;
+	uint8_t vscale_mode;
+	uint16_t vscale_border;
+	uint8_t rbf_hide_datecode;
+	uint8_t menu_pal;
+	int16_t bootcore_timeout;
+	uint8_t fb_size;
+	uint8_t fb_terminal;
+	uint8_t osd_rotate;
+	uint16_t osd_timeout;
+	uint8_t gamepad_defaults;
+	uint8_t recents;
+	uint16_t jamma_vid;
+	uint16_t jamma_pid;
+	uint16_t no_merge_vid;
+	uint16_t no_merge_pid;
+	uint32_t no_merge_vidpid[256];
+	uint16_t spinner_vid;
+	uint16_t spinner_pid;
+	int spinner_throttle;
+	uint8_t spinner_axis;
+	uint8_t sniper_mode;
+	uint8_t browse_expand;
+	uint8_t logo;
+	uint8_t log_file_entry;
+	uint8_t shmask_mode_default;
+	int bt_auto_disconnect;
+	int bt_reset_before_pair;
+	char bootcore[256];
+	char video_conf[1024];
+	char video_conf_pal[1024];
+	char video_conf_ntsc[1024];
+	char font[1024];
+	char shared_folder[1024];
+	char waitmount[1024];
+	char custom_aspect_ratio[2][16];
+	char afilter_default[1023];
+	char vfilter_default[1023];
+	char vfilter_vertical_default[1023];
+	char vfilter_scanlines_default[1023];
+	char shmask_default[1023];
+	char preset_default[1023];
+	char player_controller[4][1024];
+	uint8_t rumble;
+	uint8_t wheel_force;
+	uint16_t wheel_range;
+	uint8_t hdmi_game_mode;
+	uint8_t vrr_mode;
+	uint8_t vrr_min_framerate;
+	uint8_t vrr_max_framerate;
+	uint8_t vrr_vesa_framerate;
+	uint16_t video_off;
+	uint8_t disable_autofire;
+	uint8_t video_brightness;
+	uint8_t video_contrast;
+	uint8_t video_saturation;
+	uint16_t video_hue;
+	char video_gain_offset[256];
+	uint8_t hdr;
+	uint16_t hdr_max_nits;
+	uint16_t hdr_avg_nits;
+	char vga_mode[16];
+	char vga_mode_int;
+	char ntsc_mode;
+} cfg_t;
+
+extern cfg_t cfg;
+
+//// functions ////
+void cfg_parse();
+void cfg_print();
+const char* cfg_get_name(uint8_t alt);
+bool cfg_has_video_sections();
+
+void cfg_error(const char *fmt, ...);
+bool cfg_check_errors(char *msg, size_t max_len);
+
+struct yc_mode
+{
+	char key[64];
+	int64_t phase_inc;
+};
+
+void yc_parse(yc_mode *yc_table, int max);
+
+#endif // __CFG_H__
diff --git a/input.cpp b/input.cpp
index 8988663..7952866 100644
--- a/input.cpp
+++ b/input.cpp
@@ -3295,6 +3295,7 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 
 						//if (is_pressed)
 						//{
+              abm->last_pressed = abm->pressed;
 							abm->pressed = is_pressed; 
 							abm->cur_state_frames = 0;
 							abm->last_frame = -1;
@@ -5813,9 +5814,35 @@ void execute_advanced_sys_button(int pnum, advancedButtonMap *abm)
 {
 
 	int sys_btn = abm->bnum;
+  static bool sstate_was_held = false;
 
+  //The only button that is valid during OSD is the savestate button
+  if (user_io_osd_is_visible() && sys_btn != SYS_BTN_SAVESTATE) return;
 	switch(sys_btn)
 	{
+      case SYS_BTN_SAVESTATE:
+
+        if (core_has_save_states() && abm->pressed && (abm->cur_state_frames > 20) && (abm->cur_state_frames <= 80))
+        {
+          sstate_was_held = true;
+          ProgressMessage("SState", "Restoring...", abm->cur_state_frames-20, 60);
+          if (abm->cur_state_frames == 80)
+          {
+            ProgressMessage(0,0,0,0);
+            ss_menu_load();
+          }
+
+        }
+        if (!abm->pressed && abm->cur_state_frames == 0)
+        {
+          if (!sstate_was_held && core_has_save_states())
+          {
+            menu_open_savestate_osd();
+          }
+          ProgressMessage(0,0,0,0);
+          sstate_was_held = false;
+        }
+        break;
 			case SYS_BTN_SCREENSHOT:
         if (abm->pressed && abm->cur_state_frames == 1)
 				  user_io_screenshot(nullptr, 1);
@@ -5843,15 +5870,18 @@ void execute_advanced_sys_button(int pnum, advancedButtonMap *abm)
 	}
 }
 
-void process_advanced_map(int pnum, int curr_frame, uint32_t joy_state)
+void process_advanced_map(int pnum, int curr_frame, uint32_t joy_state, bool only_sys)
 {
-	autofire_new[pnum] = joy_state;
+  //only_sys flag only processes the system functions, in case some of them need to work in the OSD
+ //
+  if (!only_sys) autofire_new[pnum] = joy_state;
 
 	for (uint i = 0; i < (sizeof(player_pad[pnum+1].advanced_map)/sizeof(advancedButtonMap)); i++)
 	{
 			advancedButtonMap *abm = &player_pad[pnum+1].advanced_map[i];
 
 			if (!abm->codes[0]) continue;
+      if (only_sys && !(abm->bnum & 0xF0)) continue;
 			
 			bool has_autofire = abm->on_frames && abm->off_frames;
 			if (abm->pressed)
@@ -5909,8 +5939,9 @@ void process_advanced_map(int pnum, int curr_frame, uint32_t joy_state)
 				}
 			} else {
 				//Also execute on button release
-				if (abm->bnum & 0xF0 && abm->cur_state_frames == 0)
+				if ((abm->bnum & 0xF0) && (abm->last_pressed != abm->pressed && abm->cur_state_frames == 0))
 				{
+
 					execute_advanced_sys_button(pnum, abm);
 					abm->cur_state_frames = 1;
 					continue;
@@ -5977,7 +6008,7 @@ int input_poll(int getchar)
 				if (joy[i] & autofire[i]) send = 1;
 			}
 
-			process_advanced_map(i, curr_frame, joy[i]);
+			process_advanced_map(i, curr_frame, joy[i], false);
 			int newdir = ((joy[i] & 0xF) != (joy_prev[i] & 0xF));
 
 			if (autofire_new[i] != joy_prev[i])
diff --git a/input.h b/input.h
index 370b1f0..75b50db 100644
--- a/input.h
+++ b/input.h
@@ -96,6 +96,7 @@ typedef struct {
         int cur_state_frames;
         advanced_button_state button_state;
         bool pressed;
+        bool last_pressed;
         int last_frame;
 } advancedButtonMap;
 
diff --git a/menu.cpp b/menu.cpp
index 703ef24..f6d4926 100644
--- a/menu.cpp
+++ b/menu.cpp
@@ -199,8 +199,13 @@ enum MENU
 	MENU_ADVANCED_MAP_EDIT1,
 	MENU_ADVANCED_MAP_EDIT2,
 	MENU_ADVANCED_MAP_CAPTURE1,
+
+  //System save state menu
+  MENU_SAVE_STATE1,
+  MENU_SAVE_STATE2,
 };
 
+static bool menu_open_savestate = false;
 static uint32_t menustate = MENU_NONE1;
 static uint32_t parentstate;
 static uint32_t menusub = 0;
@@ -797,6 +802,7 @@ static void vga_nag()
 		EnableOsd_on(OSD_HDMI);
 	}
 
+
 	OsdDisable();
 	EnableOsd_on(OSD_ALL);
 }
@@ -1127,6 +1133,7 @@ void HandleUI(void)
 	minus = false;
 	recent = false;
 
+  if (menu_open_savestate) {menu = true;}
 	if (c && cfg.bootcore[0] != '\0') cfg.bootcore[0] = '\0';
 
 	if (is_menu() && cfg.osd_timeout >= 5)
@@ -1403,6 +1410,7 @@ void HandleUI(void)
 			{
 				SelectFile("", 0, SCANO_CORES, MENU_CORE_FILE_SELECTED1, MENU_NONE1);
 			}
+      else if (menu_open_savestate) { menustate = MENU_SAVE_STATE1; menu_open_savestate = false;}
 			else if (saved_menustate)
 			{
 				menustate = saved_menustate;
@@ -3264,6 +3272,78 @@ void HandleUI(void)
 					}
 					break;
 				}
+  case MENU_SAVE_STATE1:
+   {
+					menustate = MENU_SAVE_STATE2;
+					parentstate = MENU_SAVE_STATE1;
+					OsdSetTitle("Save States", 0);
+          char ss_descr[1024];
+          int d_status = ss_menu_get_descr(&ss_descr[1], sizeof(ss_descr)-1);
+          
+					menumask = 0x0D;
+					uint32_t n = 0;
+
+					snprintf(s, sizeof(s), " Slot %d", ss_menu_get_slot());
+          MenuWrite(n, s, menusub == n, 0); n++;
+
+          if (d_status)
+          {
+            ss_descr[0] = ' ';
+            MenuWrite(n, ss_descr, menusub == n, 0); n++;
+          } else {
+            MenuWrite(n, " <empty>", menusub == n, 0); n++;
+          }
+
+          MenuWrite(n, " Save", menusub == n, 0); n++;
+					MenuWrite(n, " Load", menusub == n, 0); n++;
+					for (int i = n; i < OsdGetSize() - 1; i++) MenuWrite(i, "", 0, 0);
+   }
+   break;
+  case MENU_SAVE_STATE2:
+   {
+     if (select || minus || plus || left || right)
+     {
+       menustate = MENU_SAVE_STATE1;
+       uint8_t curr_save_slot = ss_menu_get_slot();
+       switch(menusub)
+       {
+         case 0:
+            if (select || plus || right)
+            {
+                curr_save_slot++;
+                if (curr_save_slot > 25) curr_save_slot = 1;
+            } else if (minus || left) {
+              if (curr_save_slot == 1)
+              {
+                curr_save_slot = 25;
+              } else {
+                curr_save_slot--;
+              }
+            }
+            ss_menu_set_slot(curr_save_slot);
+           break;
+         case 2:
+           if (select)
+           {
+            ss_menu_save();
+            menustate = MENU_NONE1;
+           }
+           break;
+        case 3:
+           if (select)
+           {
+             ss_menu_load();
+             menustate = MENU_NONE1;
+           }
+           break;
+       }
+     }
+     if (menu)
+     {
+        menustate = MENU_NONE1;
+     }
+   }
+   break;
 	case MENU_DOC_FILE_SELECTED:
 		if (cfg.fb_terminal)
 		{
@@ -7620,3 +7700,15 @@ void ProgressMessage(const char* title, const char* text, int current, int max)
 		InfoMessage(progress_buf, 2000, title);
 	}
 }
+
+
+void menu_open_savestate_osd()
+{
+  if (!user_io_osd_is_visible())
+  {
+    menu_open_savestate = true;
+  } else if (menustate == MENU_SAVE_STATE1 || menustate == MENU_SAVE_STATE2) {
+    menu_open_savestate = false;
+    menustate = MENU_NONE1;
+  }
+}
diff --git a/menu.h b/menu.h
index 5f6cb4f..ba6e002 100644
--- a/menu.h
+++ b/menu.h
@@ -22,5 +22,6 @@ int menu_lightgun_cb(int idx, uint16_t type, uint16_t code, int value);
 int menu_allow_cfg_switch();
 void StoreIdx_F(int idx, const char *path);
 void StoreIdx_S(int idx, const char *path);
+void menu_open_savestate_osd();
 
 #endif
diff --git a/user_io.cpp b/user_io.cpp
index aa40cb1..d88e281 100644
--- a/user_io.cpp
+++ b/user_io.cpp
@@ -38,6 +38,10 @@
 
 #include "support.h"
 
+static char ss_rom_name[1024] = {};
+static uint8_t ss_save_slot = 1;
+static bool ss_save_pending = false;
+
 static char core_path[1024] = {};
 static char rbf_path[1024] = {};
 
@@ -1784,6 +1788,7 @@ int process_ss(const char *rom_name, int enable)
 
 		FileGenerateSavestatePath(rom_name, ss_name, 1);
 		ss_sufx = ss_name + strlen(ss_name) - 4;
+    strcpy(ss_rom_name, rom_name);
 		return 1;
 	}
 
@@ -1801,6 +1806,7 @@ int process_ss(const char *rom_name, int enable)
 			uint32_t curcnt = ((uint32_t*)(base[i]))[0];
 			uint32_t size = ((uint32_t*)(base[i]))[1];
 
+      if (i == 0) printf("CURCNT %d\n", curcnt);
 			if (curcnt != ss_cnt[i])
 			{
 				ss_cnt[i] = curcnt;
@@ -1810,12 +1816,19 @@ int process_ss(const char *rom_name, int enable)
 					MenuHide();
 					Info("Saving the state", 500);
 
-					*ss_sufx = i + '1';
-					if (FileOpenEx(&f, ss_name, O_CREAT | O_TRUNC | O_RDWR | O_SYNC))
+          char save_name[1024];
+          if (ss_save_pending)
+          {
+            FileGenerateSavestatePath(ss_rom_name, save_name, ss_save_slot);  
+          } else {
+					  *ss_sufx = i + '1';
+            strcpy(save_name, ss_name);
+          }
+					if (FileOpenEx(&f, save_name, O_CREAT | O_TRUNC | O_RDWR | O_SYNC))
 					{
 						int ret = FileWriteAdv(&f, base[i], size);
 						FileClose(&f);
-						printf("Wrote %d bytes to file: %s\n", ret, ss_name);
+						printf("Wrote %d bytes to file: %s base %d\n", ret, ss_name, ss_base);
 					}
 					else
 					{
@@ -4032,3 +4045,80 @@ void user_io_screenshot_cmd(const char *cmd)
 
 	user_io_screenshot(cmd,0);
 }
+
+
+
+bool core_has_save_states()
+{
+  return (ss_base != 0 && cfg.ss_save_bit[0]);
+}
+
+
+static int current_core_save_slot()
+{
+  if (cfg.ss_current_slot[0])
+  {
+      return user_io_status_get(cfg.ss_current_slot, 0);
+  }
+
+  return -1;
+}
+
+
+int ss_menu_get_descr(char *descr, int descr_sz)
+{
+  char ss_name[1024] = {};
+  if (!ss_base || !ss_rom_name[0]) return 0;
+  FileGenerateSavestatePath(ss_rom_name, ss_name, ss_save_slot);
+  if (!FileExists(ss_name)) return 0;
+  struct stat64 *st = getPathStat(ss_name);
+  snprintf(descr, descr_sz, "%s", ctime(&st->st_mtime));
+  return 1;
+}
+
+void ss_menu_load()
+{
+  char ss_name[1024] = {};
+  fileTYPE ss_file;
+  uint32_t map_addr = 0;
+  int current_core_slot = current_core_save_slot(); 
+  if (!cfg.ss_save_bit[0]) return;
+  if (!ss_base || current_core_slot == -1) return;
+
+  FileGenerateSavestatePath(ss_rom_name, ss_name, ss_save_slot);
+  if (!FileExists(ss_name)) return;
+  if (!FileOpen(&ss_file, ss_name)) return;
+  map_addr = ss_base + (ss_size * current_core_slot);
+  if (!map_addr) return;
+  void *ssmap = shmem_map(map_addr, ss_size);
+  if (!ssmap) return;
+  FileReadAdv(&ss_file, ssmap, ss_size);
+  FileClose(&ss_file);
+	*(uint32_t*)(ssmap) = 0xFFFFFFFF;
+  shmem_unmap(ssmap, ss_size);
+  user_io_status_set(cfg.ss_load_bit, 1);
+  user_io_status_set(cfg.ss_load_bit, 0);
+}
+
+void ss_menu_set_slot(uint8_t slot)
+{
+  ss_save_slot = slot;
+}
+
+uint8_t ss_menu_get_slot()
+{
+  return ss_save_slot;
+}
+
+
+void ss_menu_save()
+{
+
+  if (!cfg.ss_save_bit[0]) return;
+
+  ss_save_pending = true;
+  user_io_status_set(cfg.ss_save_bit, 1);
+  user_io_status_set(cfg.ss_save_bit, 0);
+}
+
+
diff --git a/user_io.h b/user_io.h
index eb6f971..33833e4 100644
--- a/user_io.h
+++ b/user_io.h
@@ -278,6 +278,16 @@ char is_arcade();
 char is_saturn();
 char is_pcxt();
 
+
+void ss_menu_load();
+void ss_menu_save();
+void ss_menu_set_slot(uint8_t slot);
+uint8_t ss_menu_get_slot();
+int ss_menu_get_descr(char *descr, int descr_sz);
+bool core_has_save_states();
+
+
+
 #define HomeDir(x) user_io_get_core_path(x)
 #define CoreName user_io_get_core_name()
 
-- 
2.39.2

