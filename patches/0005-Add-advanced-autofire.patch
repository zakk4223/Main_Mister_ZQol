From 847f57ccaa66005ae59080f2eb9d8a5e08bc1b4e Mon Sep 17 00:00:00 2001
From: Zakk <zakk@rsdio.com>
Date: Thu, 23 Oct 2025 11:19:43 -0400
Subject: [PATCH 05/11] 0005

---
 input.cpp | 150 ++++++++++++++++++++++++++++++++++++++++++++++++++++--
 input.h   |  13 ++++-
 menu.cpp  |  66 +++++++++++++++++++++++-
 video.cpp |   5 ++
 video.h   |   1 +
 5 files changed, 229 insertions(+), 6 deletions(-)

diff --git a/input.cpp b/input.cpp
index 3d10d83..a26909f 100644
--- a/input.cpp
+++ b/input.cpp
@@ -37,7 +37,9 @@
 #define NUMPLAYERS 6
 #define UINPUT_NAME "MiSTer virtual input"
 
+static int GetCurrentFrame();
 bool update_advanced_state(int devnum, uint16_t evcode, int evstate, int osd_event);
+static void input_advanced_framecheck();
 bool osd_inhibit_next_release = false;
 
 char joy_bnames[NUMBUTTONS][32] = {};
@@ -6030,6 +6032,7 @@ int input_poll(int getchar)
 	static uint32_t send_prev[NUMPLAYERS] = {};
 
 	int ret = input_test(getchar);
+  input_advanced_framecheck();
 	if (getchar) return ret;
 
 	uinp_check_key();
@@ -6282,6 +6285,8 @@ static void advanced_convert_jkmap(int devnum)
 static void process_abm_entry(advancedButtonMap *abm, advancedButtonState *abs, int devnum, int pnum)
 {
 	uint64_t joy_sav = 0;
+  if (abs->autofire_state == AF_BUTTON_DELAY) return;
+
 	if (pnum >= 0)
 	{
 		joy_sav = joy[pnum];
@@ -6310,6 +6315,93 @@ static void process_abm_entry(advancedButtonMap *abm, advancedButtonState *abs,
 	}
 }
 
+static void input_advanced_framecheck()
+{
+
+  //joy_adv[pnum] needs adjusting for autofire. However, it also needs to preserve
+  //any current non-autofire state. Instead of calling process_abm_entry, just use the current
+  //mask state to twiddle bits. 
+  //This (probably?) means autofiring something that doesn't result in a button being sent to the
+  //core won't work. What weird stuff are you doing that you are autofiring a system shortcut? No.
+
+  static int cur_frame_val = -1;
+
+  int saved_frame_val = cur_frame_val;
+  cur_frame_val = GetCurrentFrame();
+  if (saved_frame_val == -1 || saved_frame_val == cur_frame_val) return;
+
+
+	for (int devnum = 0; devnum < NUMDEV; devnum++)
+	{
+
+	  int pnum = input[devnum].num -1;
+	  if (!input[devnum].num) {
+		  int kbd_emu = user_io_get_kbdemu();
+		  if (kbd_emu == EMU_JOY0)
+			  pnum = 0;
+		  else if (kbd_emu == EMU_JOY1)
+			  pnum = 1;
+	  }
+
+    uint32_t no_autofire_mask = 0;
+    uint32_t autofire_mask = 0;
+
+  	for (uint i = 0; i < ADVANCED_MAP_MAX; i++)
+	  {
+		  advancedButtonMap *abm = &input[devnum].advanced_map[i];
+  		advancedButtonState *abs = &input[devnum].advanced_state[i];
+      bool has_autofire = abm->on_frames && abm->off_frames;
+
+      if (!has_autofire)
+      {
+        no_autofire_mask |= abs->current_mask;
+        continue;
+      }
+
+      if (!abs->pressed)
+      {
+        abs->cur_state_frames = 0;
+        continue;
+      }
+
+      abs->cur_state_frames++;
+
+
+      if(abs->autofire_state == AF_BUTTON_ON)
+      {
+        if (abs->cur_state_frames > abm->on_frames)
+        {
+          abs->cur_state_frames = 1;
+          abs->autofire_state = AF_BUTTON_OFF;
+          if (pnum >= 0) autofire_mask &= ~abs->current_mask;
+        }
+      } else if (abs->autofire_state == AF_BUTTON_OFF) {
+        if (abs->cur_state_frames > abm->off_frames)
+        {
+          abs->cur_state_frames = 1;
+          abs->autofire_state = AF_BUTTON_ON;
+          if (pnum >= 0) autofire_mask |= abs->current_mask; 
+        }
+      } else if (abs->autofire_state == AF_BUTTON_DELAY) {
+        if (abs->cur_state_frames > abm->delay_frames)
+        {
+          abs->cur_state_frames = 1;
+          abs->autofire_state = AF_BUTTON_ON;
+          process_abm_entry(abm, abs, devnum, pnum);
+        }
+      }
+
+      //Add support for AF_BUTTON_DELAY
+
+    }
+
+    if (pnum >= 0)
+    {
+      joy_adv[pnum] = autofire_mask | no_autofire_mask;
+    }
+  }
+}
+
 bool update_advanced_state(int devnum, uint16_t evcode, int evstate, int osd_event)
 {
 	bool allow_keysend = true;
@@ -6389,6 +6481,9 @@ bool update_advanced_state(int devnum, uint16_t evcode, int evstate, int osd_eve
 
 		if (abs->pressed != abs->last_pressed) 
 		{
+      if (abm->delay_frames)
+        abs->autofire_state = AF_BUTTON_DELAY;
+
   		process_abm_entry(abm, abs, devnum, pnum);
       if (pnum >= 0)
       {
@@ -6405,9 +6500,12 @@ bool update_advanced_state(int devnum, uint16_t evcode, int evstate, int osd_eve
         send_autofire_msg(pnum, abs->autofire);
 				osd_inhibit_next_release = true;
 			}
-			joy_adv[pnum] |= abs->current_mask;
-      if (!abs->autofire)
-        joy_adv_af[pnum] |= abs->current_mask; 
+      if (abs->autofire_state != AF_BUTTON_DELAY)
+      {
+			  joy_adv[pnum] |= abs->current_mask;
+        if (!abs->autofire)
+          joy_adv_af[pnum] |= abs->current_mask; 
+      }
 		}
 	}
 	return allow_keysend;
@@ -6633,3 +6731,49 @@ advancedButtonMap *input_advanced_find_match(uint16_t *input_codes, size_t code_
 	return NULL;
 }
 
+static int current_frame = -1;
+static unsigned long current_timer = 0;
+static int frame_fd = -1;
+
+static uint32_t read_kernel_fb_frame()
+{
+
+	char buffer[16];
+	if (frame_fd == -1)
+	{
+		frame_fd = open("/sys/module/MiSTer_fb/parameters/frame_count", O_RDONLY);
+	}
+
+	int sz = pread(frame_fd, buffer, sizeof(buffer)-1, 0);
+	buffer[sz] = 0;
+	return strtoul(buffer, NULL, 10);
+}
+
+static int GetCurrentFrame()
+{
+
+  if (current_frame == -1)
+  {
+
+    current_frame = read_kernel_fb_frame();
+    return current_frame;
+  }
+
+  //Don't start using the timer until we've seen at least one frame transition.
+
+
+  if (CheckTimer(current_timer))
+  {
+    int frame_num = read_kernel_fb_frame();
+    if (frame_num != current_frame)
+    {
+      float frame_ms = video_get_vtime_ms();
+      //Try 80% of frame time...
+      frame_ms*=0.80;
+      current_timer = GetTimer((unsigned long)frame_ms); 
+      current_frame = frame_num;
+    }
+  }
+  return current_frame;
+
+}
diff --git a/input.h b/input.h
index 16f7187..fe2611b 100644
--- a/input.h
+++ b/input.h
@@ -79,13 +79,24 @@ typedef struct {
         uint32_t button_mask;
 				uint16_t output_codes[4];
         uint16_t input_codes[4];
+        uint8_t on_frames;
+        uint8_t off_frames;
+        uint8_t delay_frames;
 } advancedButtonMap;
 
 
-typedef struct {
+typedef enum
+{
+  AF_BUTTON_ON = 0,
+  AF_BUTTON_OFF,
+  AF_BUTTON_DELAY
+} advancedAutofireState;
 
+typedef struct {
 	uint8_t input_state;
 	uint32_t current_mask;
+  uint8_t cur_state_frames;
+  advancedAutofireState autofire_state;
 	uint8_t pressed : 1;
 	uint8_t last_pressed : 1;
 	uint8_t autofire : 1;
diff --git a/menu.cpp b/menu.cpp
index 2040835..3e50aa0 100644
--- a/menu.cpp
+++ b/menu.cpp
@@ -7531,6 +7531,7 @@ void HandleUI(void)
 					advancedButtonMap *edit_abm = abms+abm_edit_idx;
 					int mapped_button_cnt = 0;
 					int first_map_idx = -1;
+          bool has_autofire = edit_abm->on_frames && edit_abm->off_frames;
 				  bool dev_kbd = device_is_keyboard(abm_dev_num);
 					for (uint bn = 0; bn < sizeof(edit_abm->button_mask)*8; bn++)
 					{
@@ -7575,6 +7576,26 @@ void HandleUI(void)
 					MenuWrite(n, s, menusub == n, 0);
 				  menumask |= 1 << n++; 
 
+          snprintf(s, sizeof(s), " Autofire %s", has_autofire ? "ON": "OFF");
+          MenuWrite(n, s, menusub == n, 0);
+          menumask |= 1 << n++;
+          
+          snprintf(s, sizeof(s), " On Frames %-14d\x10 \x11", edit_abm->on_frames);
+          MenuWrite(n, s, menusub == n, !has_autofire);
+          if (has_autofire) menumask |= 1 << n;
+          n++;
+
+          snprintf(s, sizeof(s), " Off Frames %-13d\x10 \x11", edit_abm->off_frames);
+          MenuWrite(n, s, menusub == n, !has_autofire);
+          if (has_autofire) menumask |= 1 << n;
+          n++;
+
+          snprintf(s, sizeof(s), " Delay Frames %-11d\x10 \x11", edit_abm->delay_frames);
+          MenuWrite(n, s, menusub == n);
+          menumask |= 1 << n;
+          n++;
+
+
 					MenuWrite(n, " Delete", menusub == n, 0);
 				  menumask |= 1 << n++; 
 					MenuWrite(n, " Done", menusub == n, 0);
@@ -7590,6 +7611,7 @@ void HandleUI(void)
 						menustate = MENU_ADVANCED_MAP_EDIT1;
 						advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
 						advancedButtonMap *edit_abm = abms+abm_edit_idx;
+            bool has_autofire = edit_abm->on_frames && edit_abm->off_frames;
             char bname[32] = {0};
 						switch(menusub)
 							{
@@ -7660,7 +7682,47 @@ void HandleUI(void)
 									}
 									break;
 								
-							case 3:
+              case 3:
+                if (select)
+                {
+                  if (has_autofire)
+                  {
+                    edit_abm->off_frames = edit_abm->on_frames = 0;
+                    
+                  } else {
+                    edit_abm->off_frames = edit_abm->on_frames = 1;
+                  }
+                }
+                break;
+
+              case 4:
+                if (select || right)
+                {
+                  edit_abm->on_frames++;
+                } else if (left) {
+                  edit_abm->on_frames--;
+                }
+                break;
+
+              case 5:
+                if (select || right)
+                {
+                  edit_abm->off_frames++;
+                } else if (left) {
+                  edit_abm->off_frames--;
+                }
+                break;
+
+              case 6:
+                if (select || right)
+                {
+                  edit_abm->delay_frames++;
+                } else if (left) {
+                  edit_abm->delay_frames--;
+                }
+                break;
+
+							case 7:
 									if (select)
 									{
 										menustate = MENU_ADVANCED_MAP_LIST1;
@@ -7670,7 +7732,7 @@ void HandleUI(void)
 										input_advanced_save(abm_dev_num);
 									}
 									break;
-								case 4:
+								case 8:
 									if (select)
 									{
 										menustate = MENU_ADVANCED_MAP_LIST1;
diff --git a/video.cpp b/video.cpp
index 78d93d6..2553bb4 100644
--- a/video.cpp
+++ b/video.cpp
@@ -4122,4 +4122,9 @@ int video_get_rotated()
   return current_video_info.rotated;
 }
 
+float video_get_vtime_ms()
+{
+  return current_video_info.vtime*1000/(float)100000000;
+}
+
 
diff --git a/video.h b/video.h
index e8e7cb7..50f10e9 100644
--- a/video.h
+++ b/video.h
@@ -51,6 +51,7 @@ void  video_set_shadow_mask(const char *name);
 void  video_loadPreset(char *name, bool save);
 
 int   video_get_rotated();
+float video_get_vtime_ms();
 
 void video_cfg_reset();
 
-- 
2.51.1.dirty

