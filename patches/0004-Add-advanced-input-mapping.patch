From 04e805fe8a222a2d42d642f5516d0e8d1960bdb2 Mon Sep 17 00:00:00 2001
From: Zakk <zakk@rsdio.com>
Date: Mon, 12 Feb 2024 03:06:15 -0500
Subject: [PATCH 4/8] 0004

---
 Makefile              |   4 +-
 gamecontroller_db.cpp |  15 +-
 gamecontroller_db.h   |   1 +
 input.cpp             | 769 +++++++++++++++++++++++++++++++++++++++---
 input.h               |  47 +++
 menu.cpp              | 731 ++++++++++++++++++++++++++++++++++++++-
 scaler.cpp            |  25 ++
 scaler.h              |   3 +-
 user_io.cpp           |   8 +-
 9 files changed, 1531 insertions(+), 72 deletions(-)

diff --git a/Makefile b/Makefile
index fb8d6c9..6e31d7d 100644
--- a/Makefile
+++ b/Makefile
@@ -48,7 +48,7 @@ OBJ	= $(C_SRC:.c=.c.o) $(CPP_SRC:.cpp=.cpp.o) $(IMG:.png=.png.o)
 DEP	= $(C_SRC:.c=.c.d) $(CPP_SRC:.cpp=.cpp.d)
 
 DFLAGS	= $(INCLUDE) -D_7ZIP_ST -DPACKAGE_VERSION=\"1.3.3\" -DFLAC_API_EXPORTS -DFLAC__HAS_OGG=0 -DHAVE_LROUND -DHAVE_STDINT_H -DHAVE_STDLIB_H -DHAVE_SYS_PARAM_H -DENABLE_64_BIT_WORDS=0 -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -DVDATE=\"`date +"%y%m%d"`\"
-CFLAGS	= $(DFLAGS) -Wall -Wextra -Wno-strict-aliasing -Wno-stringop-overflow -Wno-stringop-truncation -Wno-format-truncation -Wno-psabi -Wno-restrict -c -O3
+CFLAGS	= $(DFLAGS) -Wall -Wextra -Wno-strict-aliasing -Wno-stringop-overflow -Wno-stringop-truncation -Wno-format-truncation -Wno-psabi -Wno-restrict -c -O3 -g
 LFLAGS	= -lc -lstdc++ -lm -lrt $(IMLIB2_LIB) -Llib/bluetooth -lbluetooth -lpthread
 
 OUTPUT_FILTER = sed -e 's/\(.[a-zA-Z]\+\):\([0-9]\+\):\([0-9]\+\):/\1(\2,\ \3):/g'
@@ -61,7 +61,7 @@ $(PRJ): $(OBJ)
 	$(Q)$(info $@)
 	$(Q)$(CC) -o $@ $+ $(LFLAGS) 
 	$(Q)cp $@ $@.elf
-	$(Q)$(STRIP) $@
+	#$(Q)$(STRIP) $@
 
 .PHONY: clean
 clean:
diff --git a/gamecontroller_db.cpp b/gamecontroller_db.cpp
index b84a0e9..6e92e17 100644
--- a/gamecontroller_db.cpp
+++ b/gamecontroller_db.cpp
@@ -195,14 +195,15 @@ static int find_linux_code_for_button(char *btn_name, uint16_t *btn_map, uint16_
 #define test_bit(bit, array)  (array [bit / 8] & (1 << (bit % 8)))
 
 
-static void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint16_t *abs_map)
+void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint16_t *abs_map)
 {
 	unsigned char keybits[(KEY_MAX+7) / 8];
 	unsigned char absbits[(ABS_MAX+7) / 8];
 	uint16_t btn_cnt = 0;
 	uint16_t abs_cnt = 0;
 
-	printf("Gamecontrollerdb: mapping buttons for %s ", guid);
+  if (guid)
+	  printf("Gamecontrollerdb: mapping buttons for %s ", guid);
 	if (ioctl(dev_fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits) >= 0)
 	{
 		for (int i = BTN_JOYSTICK; i < KEY_MAX; i++)
@@ -223,11 +224,14 @@ static void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint1
 					btn_cnt++;
 				}
 		}
-		printf("\n");
+    if (guid)
+		  printf("\n");
 
 	}
 
-	printf("Gamecontrollerdb: mapping analog axes for %s ", guid);
+  
+  if (guid)
+	  printf("Gamecontrollerdb: mapping analog axes for %s ", guid);
 	if (ioctl(dev_fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits) >= 0)
 	{
 		//The "correct" way is to test  all the way to ABS_MAX and skip any hats the device has.
@@ -253,7 +257,8 @@ static void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint1
 				}
 		}
 	}
-	printf("\n");
+  if (guid)
+	  printf("\n");
 }
 
 void gcdb_show_string_for_ctrl_map(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version,int dev_fd, const char *name, uint32_t *cur_map)
diff --git a/gamecontroller_db.h b/gamecontroller_db.h
index 0010c58..42540aa 100644
--- a/gamecontroller_db.h
+++ b/gamecontroller_db.h
@@ -11,6 +11,7 @@
 
 bool gcdb_map_for_controller(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version, int dev_fd, uint32_t *fill_map);
 void gcdb_show_string_for_ctrl_map(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version,int dev_fd, const char *name, uint32_t *cur_map);
+void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint16_t *abs_map);
 #endif
 
 
diff --git a/input.cpp b/input.cpp
index d3de2c8..b4dcbaf 100644
--- a/input.cpp
+++ b/input.cpp
@@ -28,6 +28,7 @@
 #include "video.h"
 #include "audio.h"
 #include "joymapping.h"
+#include "scaler.h"
 #include "support.h"
 #include "profiling.h"
 #include "gamecontroller_db.h"
@@ -37,6 +38,9 @@
 #define NUMPLAYERS 6
 #define UINPUT_NAME "MiSTer virtual input"
 
+
+void update_advanced_state(int devnum, int origcode, int evcode);
+
 char joy_bnames[NUMBUTTONS][32] = {};
 int  joy_bcount = 0;
 static struct pollfd pool[NUMDEV + 3];
@@ -1204,6 +1208,13 @@ typedef struct
 	float    max_range[2];
 
 	uint32_t deadzone;
+	unsigned char state_bits[(KEY_MAX + 7) / 8];
+	uint16_t btn_map[KEY_MAX - BTN_JOYSTICK] = {0};
+	uint16_t abs_map[ABS_MAX] = {0};
+	//Top half. user defined core buttons
+	//Bottom half. user defined 'system' buttons (from main menu)
+	advancedButtonMap advanced_map[(ADVANCED_MAP_MAX*2)+1];
+	uint32_t analogAxisMap[8]; //lx+,lx-,ly+,ly-, repeat for right stick
 } devInput;
 
 static devInput input[NUMDEV] = {};
@@ -1221,6 +1232,77 @@ static devInput player_pdsp[NUMPLAYERS] = {};
 int mfd = -1;
 int mwd = -1;
 
+
+bool inhibit_osd_release = false;
+bool osd_key_is_down = false;
+
+uint32_t *get_analog_remap_defs(int devnum)
+{
+	if (devnum < 0 || devnum >= NUMDEV)
+	{
+		return NULL;
+	}
+	return input[devnum].analogAxisMap;
+}
+
+
+advancedButtonMap *get_advanced_map_defs(int devnum)
+{
+	if (devnum < 0 || devnum >= NUMDEV)
+	{
+		return NULL;
+	}
+	return input[devnum].advanced_map; 
+}
+
+void get_button_name_for_code(uint16_t btn_code, int devnum, char *bname, size_t bname_sz)
+{
+  snprintf(bname, bname_sz, "??");
+  if (btn_code >= KEY_EMU) //hat/analog
+  {
+    bool is_max = btn_code & 0x1;
+    uint16_t axis_idx = (btn_code - KEY_EMU) >> 1;
+    if (axis_idx >= ABS_HAT0X && axis_idx <= ABS_HAT3Y)
+    {
+      uint8_t hat_num = (axis_idx - ABS_HAT0X)/2;
+      bool axis_is_y = (axis_idx - ABS_HAT0X)%2;
+      uint8_t hat_sub = 0;
+      if (axis_is_y)
+      {
+        hat_sub = is_max ? 4 : 1;
+      } else {
+        hat_sub = is_max ? 2 : 8;
+      }
+      if (hat_sub)
+      {
+        snprintf(bname,bname_sz, "h%d.%d", hat_num, hat_sub);
+      }
+    } else {
+      //Mister 'fake' analog digital inputs.
+      for(unsigned int j=0; j < sizeof(input[devnum].abs_map)/sizeof(uint16_t); j++)
+      {
+        if (input[devnum].abs_map[j] == axis_idx)
+        {
+          if (is_max)
+            snprintf(bname, bname_sz, "+a%d", j);
+          else
+            snprintf(bname, bname_sz, "-a%d", j);
+          break;
+        }
+      }
+    }
+  } else {
+    for(unsigned int j=0; j < sizeof(input[devnum].btn_map)/sizeof(uint16_t); j++)
+    {
+      if (input[devnum].btn_map[j] == 0xFFFF) break;
+      if (input[devnum].btn_map[j] == btn_code) {
+        snprintf(bname, bname_sz, "b%d", j);
+        break;
+      }
+    }
+  }
+}
+
 static int set_watch()
 {
 	mwd = -1;
@@ -1400,6 +1482,14 @@ static int mapping_set;
 static int mapping_current_key = 0;
 static int mapping_current_dev = -1;
 
+static bool ev_capturing = false;
+static int ev_capture_dnum = -1;
+static uint32_t captured_ev_code = 0;
+static bool ev_capture_cancellable = false;
+static bool ev_capture_keyboard = false;
+static bool ev_capture_seen_press = false;
+
+
 static uint32_t tmp_axis[4];
 static int tmp_axis_n = 0;
 
@@ -1605,6 +1695,32 @@ void finish_map_setting(int dismiss)
 	}
 }
 
+
+void start_code_capture(int dnum, bool cancellable, bool keyboard)
+{
+
+	ev_capture_dnum = dnum;
+	ev_capturing = true;
+	ev_capture_keyboard = keyboard;
+	ev_capture_cancellable = cancellable;
+	captured_ev_code = 0;
+	ev_capture_seen_press = false;
+}
+
+void end_code_capture()
+{
+	ev_capturing = false;
+	ev_capture_cancellable = false;
+	captured_ev_code = 0;
+	ev_capture_keyboard = false;
+	ev_capture_seen_press = false;
+}
+
+uint32_t get_captured_code()
+{
+	return captured_ev_code;
+}
+
 void input_lightgun_save(int idx, int32_t *cal)
 {
 	static char name[128];
@@ -1714,6 +1830,7 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 static int kbd_toggle = 0;
 static uint32_t joy[NUMPLAYERS] = {};
 static uint32_t autofire[NUMPLAYERS] = {};
+static uint32_t autofire_new[NUMPLAYERS] = {};
 static uint32_t autofirecodes[NUMPLAYERS][BTN_NUM] = {};
 static int af_delay[NUMPLAYERS] = {};
 
@@ -1732,6 +1849,7 @@ static int mouse_emu_x = 0;
 static int mouse_emu_y = 0;
 
 static uint32_t mouse_timer = 0;
+static mister_scaler *scaler_inst = NULL;
 
 #define BTN_TGL 100
 #define BTN_OSD 101
@@ -2142,9 +2260,22 @@ static void joy_digital(int jnum, uint32_t mask, uint32_t code, char press, int
 				break;
 
 			default:
-				ev.code = (bnum == BTN_OSD) ? KEY_MENU : 0;
+        if (bnum == BTN_OSD)
+        {
+          if (!ev.value)
+          {
+            if (inhibit_osd_release)
+            {
+              inhibit_osd_release = false;
+              ev.code = 0;
+            } else {
+              ev.code = KEY_MENU;
+            }
+          } else {
+            ev.code = KEY_MENU;
+          }
+        }
 			}
-
 			input_cb(&ev, 0, 0);
 		}
 		else if (video_fb_state())
@@ -2531,8 +2662,6 @@ static void setup_deadzone(struct input_event* ev, int dev)
 void swap_player(int cur_dev, int new_num)
 {
 
-        int dest_dev = -1;
-	int cur_num = input[cur_dev].num;
 	bool is_pdsp = false;
 	if (input[cur_dev].quirk == QUIRK_PDSP || input[cur_dev].quirk == QUIRK_MSSP)
 	{
@@ -2548,11 +2677,9 @@ void swap_player(int cur_dev, int new_num)
 
 				if (is_pdsp)
 				{
-					dest_dev = i;
 					break;
 				}
 			} else if (!is_pdsp) {
-				dest_dev = i;
 				break;
 			}
                 }
@@ -2564,12 +2691,6 @@ void swap_player(int cur_dev, int new_num)
 	}
         input[cur_dev].num = new_num;
         store_player(new_num, cur_dev);
-        //Swap if there was already one assigned there
-        if (dest_dev > -1)
-        {
-                input[dest_dev].num = cur_num;
-                store_player(cur_num, dest_dev);
-        }
 }
 
 
@@ -2618,9 +2739,46 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 
 	int sub_dev = dev;
 
+
 	//check if device is a part of multifunctional device
 	if (!JOYCON_COMBINED(dev) && input[dev].bind >= 0) dev = input[dev].bind;
 
+
+	if (ev_capturing && ev->value && ev->type == EV_KEY)
+	{
+		ev_capture_seen_press = true;
+	}
+
+
+	if (ev_capturing && ev_capture_seen_press && ev_capture_keyboard && ev->type == EV_KEY && ev->code < 256)
+	{
+		if (ev_capture_cancellable && ev->code == input[dev].mmap[SYS_BTN_MENU_FUNC] >> 16)
+		{
+			captured_ev_code = 0xFFFFFFFF;
+			return;
+		}
+		captured_ev_code = ev->code;
+		if (ev->value)
+		{
+			captured_ev_code |= 0x80000000;
+		}
+		return;
+	}
+	if (ev_capturing && ev_capture_seen_press && ev_capture_dnum == dev && ev->type == EV_KEY && !ev_capture_keyboard)
+	{
+		if (ev_capture_cancellable && ev->code == input[dev].mmap[SYS_BTN_MENU_FUNC] >> 16)
+		{
+			captured_ev_code = 0xFFFFFFFF;
+			return;
+		}
+		captured_ev_code = ev->code;
+		if (ev->value)
+		{
+			captured_ev_code |= 0x80000000;
+		}
+		return;
+	}
+
 	if (ev->type == EV_KEY)
 	{
 		if (input[dev].timeout > 0) input[dev].timeout = cfg.bt_auto_disconnect * 10;
@@ -2660,6 +2818,7 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 	int enter    = (ev->type == EV_KEY && ev->code == KEY_ENTER && !(mapping && mapping_type == 3 && mapping_button));
 	int origcode = ev->code;
 
+  
 	if (!input[dev].has_mmap)
 	{
 		if (input[dev].quirk == QUIRK_TOUCHGUN)
@@ -2672,6 +2831,7 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 		}
 		else if (input[dev].quirk != QUIRK_PDSP && input[dev].quirk != QUIRK_MSSP)
 		{
+      get_ctrl_index_maps(pool[sub_dev].fd, NULL, input[dev].btn_map, input[dev].abs_map);
 			if (!load_map(get_map_name(dev, 1), &input[dev].mmap, sizeof(input[dev].mmap)))
 			{
 				if (!gcdb_map_for_controller(input[sub_dev].bustype, input[sub_dev].vid, input[sub_dev].pid, input[sub_dev].version, pool[sub_dev].fd, input[dev].mmap))
@@ -2747,6 +2907,9 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 			}
 			input[dev].has_map++;
 		}
+
+		input_advanced_load(dev);
+
 		input[dev].has_map++;
 	}
 
@@ -3263,6 +3426,7 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 				last_input_dev = dev;
 			}*/
 
+			last_input_dev = dev;
 			if (ev->code >= 256)
 			{
 				if (input[dev].lightgun_req && !user_io_osd_is_visible())
@@ -3275,16 +3439,24 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 				}
 				else
 				{
-					if (osd_event == 1) joy_digital(input[dev].num, 0, 0, 1, BTN_OSD);
-					if (osd_event == 2) joy_digital(input[dev].num, 0, 0, 0, BTN_OSD);
+					if (osd_event == 1) 
+          {
+            joy_digital(input[dev].num, 0, 0, 1, BTN_OSD);
+            osd_key_is_down = true;
+          }
+					if (osd_event == 2) 
+          {
+            joy_digital(input[dev].num, 0, 0, 0, BTN_OSD);
+            osd_key_is_down = false;
+          }
 				}
 
 				if (user_io_osd_is_visible() || video_fb_state())
 				{
-					if (player_num_remapping && input[dev].num)
+					/*if (input[dev].num)
 					{
 						last_input_dev = dev;
-					}
+					}*/
 
 					if (ev->value <= 1)
 					{
@@ -3418,6 +3590,15 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 						input[dev].has_map = 1;
 					}
 
+					//maintain the current state bitmap
+					if (ev->value)
+					{
+						input[dev].state_bits[ev->code / 8] |= (1 << (ev->code % 8));
+
+					} else {
+						input[dev].state_bits[ev->code / 8] &= ~(1 << (ev->code % 8));
+					}
+
 					for (uint i = 0; i < BTN_NUM; i++)
 					{
 						if (ev->code == (input[dev].map[i] & 0xFFFF) || ev->code == (input[dev].map[i] >> 16))
@@ -3428,6 +3609,7 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 							// support 2 simultaneous functions for 1 button if defined in 2 sets. No return.
 						}
 					}
+					update_advanced_state(dev, origcode, ev->code);
 
 					if (ev->code == input[dev].mmap[SYS_MS_BTN_EMU] && (ev->value <= 1) && ((!(mouse_emu & 1)) ^ (!ev->value)))
 					{
@@ -3455,6 +3637,13 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 			{
 				//  replace MENU key by RGUI to allow using Right Amiga on reduced keyboards
 				// (it also disables the use of Menu for OSD)
+				if (ev->value)
+				{
+					input[dev].state_bits[ev->code / 8] |= (1 << (ev->code % 8));
+				} else {
+					input[dev].state_bits[ev->code / 8] &= ~(1 << (ev->code % 8));
+				}
+
 				if (cfg.key_menu_as_rgui && ev->code == KEY_COMPOSE) ev->code = KEY_RIGHTMETA;
 
 				//Keyrah v2: USB\VID_18D8&PID_0002\A600/A1200_MULTIMEDIA_EXTENSION_VERSION
@@ -3479,9 +3668,10 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 							{
 								if (i <= 3 && origcode == ev->code) origcode = 0; // prevent autofire for original dpad
 								if (ev->value <= 1) joy_digital((user_io_get_kbdemu() == EMU_JOY0) ? 1 : 2, 1 << i, origcode, ev->value, i);
-								return;
+								//return;
 							}
 						}
+						update_advanced_state(dev, origcode, ev->code);
 					}
 
 					if (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL])
@@ -3663,22 +3853,64 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 					else
 					{
 						int offset = (value < -1 || value > 1) ? value : 0;
-						if (input[dev].stick_l[0] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_l[0]])
-						{
-							joy_analog(dev, 0, offset, 0);
-						}
-						else if (input[dev].stick_l[1] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_l[1]])
-						{
-							joy_analog(dev, 1, offset, 0);
-						}
-						else if (input[dev].stick_r[0] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_r[0]])
-						{
-							joy_analog(dev, 0, offset, 1);
+						bool axis_remapped = false;
+						for (uint i = 0; i < sizeof(input[dev].analogAxisMap)/sizeof(input[dev].analogAxisMap[0]); i++) 
+						{	
+							uint16_t btn_code = input[dev].analogAxisMap[i];
+							bool is_max = btn_code & 0x1;
+							uint16_t axis_idx = (btn_code - KEY_EMU) >> 1;
+							if (ev->code == axis_idx) 
+							{
+								int stick_num = i < 4 ? 0 : 1;
+								int stick_dir = i % 2 ? -1 : 1;
+								int stick_axis = i/2;
+
+								if (is_max && offset >= 0)
+								{
+									joy_analog(dev, stick_axis, abs(offset)*stick_dir, stick_num);
+									axis_remapped = true;
+								}
+
+								if (!is_max && offset <= 0)
+								{
+									joy_analog(dev, stick_axis, abs(offset)*stick_dir, stick_num);
+									axis_remapped = true;
+								}
+
+							}
+
+
 						}
-						else if (input[dev].stick_r[1] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_r[1]])
+
+						if (!axis_remapped)
 						{
-							joy_analog(dev, 1, offset, 1);
-						}
+							if (input[dev].stick_l[0] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_l[0]])
+							{
+								int map_idx = offset > 0 ? 0 : 1; 
+								if (!input[dev].analogAxisMap[map_idx])
+									joy_analog(dev, 0, offset, 0);
+							}
+							else if (input[dev].stick_l[1] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_l[1]])
+							{
+								int map_idx = offset > 0 ? 2 : 3; 
+								if (!input[dev].analogAxisMap[map_idx])
+									joy_analog(dev, 1, offset, 0);
+							}
+							else if (input[dev].stick_r[0] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_r[0]])
+							{
+
+								int map_idx = offset > 0 ? 4 : 5; 
+								if (!input[dev].analogAxisMap[map_idx])
+									joy_analog(dev, 0, offset, 1);
+							}
+							else if (input[dev].stick_r[1] && ev->code == (uint16_t)input[dev].mmap[input[dev].stick_r[1]])
+							{
+
+								int map_idx = offset > 0 ? 6 : 7; 
+								if (!input[dev].analogAxisMap[map_idx])
+									joy_analog(dev, 1, offset, 1);
+							}
+ 						}
 					}
 				}
 			}
@@ -5087,6 +5319,12 @@ int input_test(int getchar)
 			unflag_players();
 		}
 		cur_leds |= 0x80;
+		if (scaler_inst)
+		{
+			mister_scaler_free(scaler_inst);
+		}
+
+		scaler_inst = mister_scaler_init();
 		state++;
 	}
 
@@ -5135,6 +5373,7 @@ int input_test(int getchar)
 					if (input[i].bind >= 0) dev = input[i].bind;
 					if (!input[dev].num) continue;
 
+
 					set_rumble(i, spi_uio_cmd(UIO_GET_RUMBLE | ((input[dev].num - 1) << 8)));
 				}
 			}
@@ -5606,7 +5845,7 @@ int input_test(int getchar)
 										int treshold = range / 4;
 
 										int only_max = 1;
-										for (int n = 0; n < 4; n++) if (input[dev].mmap[SYS_AXIS1_X + n] && ((input[dev].mmap[SYS_AXIS1_X + n] & 0xFFFF) == ev.code)) only_max = 0;
+										for (int n = 0; n < 4; n++) if (input[dev].mmap[SYS_AXIS1_X + n] && ((input[dev].mmap[SYS_AXIS1_X + n] & 0xFFFF) == ev.code)) {only_max = 0;};
 
 										if (ev.value < center - treshold && !only_max) axis_edge = 1;
 										if (ev.value > center + treshold) axis_edge = 2;
@@ -5799,6 +6038,236 @@ int input_test(int getchar)
 	return 0;
 }
 
+
+void execute_advanced_sys_button(int pnum, advancedButtonMap *abm) 
+{
+
+	for (uint i = 0; i < sizeof(abm->bnum)/sizeof(abm->bnum[0]); i++)
+	{
+		if (abm->bnum[i] < 0) break;
+		int sys_btn = abm->bnum[i];
+		if (!(sys_btn & 0xF0)) continue;
+
+		switch(sys_btn)
+		{
+				case SYS_BTN_SCREENSHOT:
+	        if (abm->pressed && abm->cur_state_frames == 1)
+					  user_io_screenshot(nullptr, 1);
+					break;
+				case SYS_BTN_RESET:
+					if (abm->pressed && abm->cur_state_frames <= 60)
+					{	
+						ProgressMessage("Resetting", "Resetting...", abm->cur_state_frames, 60);
+						if (abm->cur_state_frames == 60)
+						{
+							ProgressMessage(0,0,0,0);
+							if (is_x86() || is_pcxt()) { x86_init(); ResetUART(); }
+							if (is_megacd()) mcd_set_image(0, "");
+							if (is_pce()) pcecd_reset();
+							if (is_saturn()) saturn_reset();
+							user_io_status_set("0", 1, 0);
+							user_io_status_set("0",0,0);
+						}
+					}
+					if (!abm->pressed)
+					{
+						ProgressMessage(0,0,0,0);
+					}
+					break;
+		}
+	}
+}
+
+
+void update_advanced_state(int devnum, int origcode, int evcode)
+{
+					for (uint i = 0; i < ADVANCED_MAP_MAX*2; i++)
+					{
+						advancedButtonMap *abm = &input[devnum].advanced_map[i];
+
+
+						bool is_pressed = true;
+
+						for (unsigned int i = 0; i < sizeof(abm->codes)/sizeof(uint32_t); i++)
+						{
+							if (!abm->codes[i]) 
+							{
+									if (i == 0) is_pressed = false;
+									break;
+							}
+							if (!(input[devnum].state_bits[abm->codes[i] / 8] & (1 << (abm->codes[i] % 8))))
+							{
+								is_pressed = false;
+								break;
+							}
+						}
+
+						if (is_pressed)
+						{
+							//In the case where an advanced button map uses a key/button from the original mapping style, turn off
+							//any mappings from original map
+							int cidx = 0;
+							while(abm->codes[cidx])
+							{
+								for (uint i = 0; i < BTN_NUM; i++)
+								{
+									if (abm->codes[cidx] == (input[devnum].map[i] & 0xFFFF) || abm->codes[cidx] == (input[devnum].map[i] >> 16))
+									{
+										joy_digital(input[devnum].num, 1 << i, origcode, 0, i, (evcode == input[devnum].mmap[SYS_BTN_OSD_KTGL + 1] || evcode == input[devnum].mmap[SYS_BTN_OSD_KTGL + 2]));
+										
+									}
+								}
+								cidx++;
+							}
+						}
+
+						//if (is_pressed)
+						//{
+							abm->last_pressed = abm->pressed;
+							abm->pressed = is_pressed; 
+							if (abm->last_pressed != abm->pressed)
+							{
+								abm->cur_state_frames = 0;
+								abm->last_frame = -1;
+							}
+							if (abm->pressed)
+							{
+                if (abm->delay_frames)
+                {
+                  abm->button_state = BUTTON_DELAY;
+                } else {
+								  abm->button_state = BUTTON_ON;
+                }
+							} else {
+								abm->button_state = BUTTON_OFF;
+							}
+						//}
+
+					}
+}
+//This function sets the button state for the given player, but will also directly
+//send keyboard events if any are mapped
+
+void process_advanced_map(int pnum, int curr_frame, uint32_t joy_state)
+{
+	//Process all input devices with matching player number
+	autofire_new[pnum] = joy_state;
+
+	int user_kbdemu = user_io_get_kbdemu();
+	for (uint devnum = 0; devnum < NUMDEV; devnum++)
+	{
+		if (!input[devnum].num)
+		{
+				if (!input[devnum].has_map && !input[devnum].has_mmap) continue;
+				if (!pnum && (user_kbdemu != EMU_JOY0)) continue;
+				if ((pnum == 1) && (user_kbdemu != EMU_JOY1)) continue;
+		} else {
+			if (input[devnum].num != pnum+1) continue;
+		}
+		for (uint i = 0; i < (sizeof(input[devnum].advanced_map)/sizeof(advancedButtonMap)); i++)
+		{
+				advancedButtonMap *abm = &input[devnum].advanced_map[i];
+
+				if (!abm->codes[0]) continue;
+				
+				bool has_sys_btn = false;
+				for (uint b = 0; b < sizeof(abm->bnum)/sizeof(abm->bnum[0]); b++)
+				{
+					if (abm->bnum[b] < 0) break;
+					if (abm->bnum[b] & 0xF0) {
+						has_sys_btn = true;
+						break;
+					}
+				}
+				bool has_autofire = abm->on_frames && abm->off_frames;
+				if (abm->pressed)
+				{
+					if (abm->last_frame != curr_frame)
+					{
+						abm->last_frame = curr_frame;
+						abm->cur_state_frames++;
+
+						if (has_autofire)
+						{
+							if (abm->button_state == BUTTON_ON)
+							{
+								if (abm->cur_state_frames > abm->on_frames)
+								{
+									abm->cur_state_frames = 1;
+									//If off_frames is set to zero, never switch state
+									//(continually pressed)
+									if (abm->off_frames)
+									{
+  	                abm->button_state = BUTTON_OFF;
+									}
+
+								}
+							} else if (abm->button_state == BUTTON_OFF) {
+								if (abm->cur_state_frames > abm->off_frames)
+								{
+									abm->cur_state_frames = 1;
+  	              abm->button_state = BUTTON_ON;
+								}
+							} else if (abm->button_state == BUTTON_DELAY) {
+  	            if (abm->cur_state_frames > abm->delay_frames)
+  	            {
+  	              abm->cur_state_frames = 1;
+  	              abm->button_state = BUTTON_ON;
+  	            }
+  	          }
+						}
+
+						if (has_sys_btn)
+						{
+  	          if (osd_key_is_down)
+  	          {
+  	            inhibit_osd_release = true;
+  	          }
+							execute_advanced_sys_button(pnum, abm);
+						}
+					}
+
+					for (uint b = 0; b < sizeof(abm->bnum)/sizeof(abm->bnum[0]); b++) 
+					{
+						int bnum = abm->bnum[b];
+						if (bnum < 0) break;
+						if (!(joy[pnum] & 1<<bnum))
+						{
+							if (abm->button_state == BUTTON_ON) autofire_new[pnum] |= 1<<bnum;
+							else  autofire_new[pnum] &= ~(1<<bnum);
+						}
+					}
+
+					for (uint k = 0; k < sizeof(abm->keycodes)/sizeof(abm->keycodes[0]); k++)
+					{
+						if (abm->keycodes[k])
+						{
+							user_io_kbd(abm->keycodes[k], abm->button_state == BUTTON_ON ? 1 : 0);
+						}
+					}
+				} else {
+					//Also execute on button release
+					if (has_sys_btn && abm->cur_state_frames == 0 && (abm->last_pressed != abm->pressed))
+					{
+						execute_advanced_sys_button(pnum, abm);
+						abm->cur_state_frames = 1;
+					}
+					if (abm->cur_state_frames == 0 && (abm->last_pressed != abm->pressed))
+					{
+						for (uint k = 0; k < sizeof(abm->keycodes)/sizeof(abm->keycodes[0]); k++)
+						{
+							if (abm->keycodes[k])
+							{
+								user_io_kbd(abm->keycodes[k], 0);
+							}
+						}
+						abm->cur_state_frames = 1;
+					}
+				}
+		}
+	}
+}
+
 int input_poll(int getchar)
 {
 	PROFILE_FUNCTION();
@@ -5841,6 +6310,8 @@ int input_poll(int getchar)
 
 	if (grabbed)
 	{
+		int curr_frame = mister_scaler_frame_counter(scaler_inst);
+
 		for (int i = 0; i < NUMPLAYERS; i++)
 		{
 			if (af_delay[i] < AF_MIN) af_delay[i] = AF_MIN;
@@ -5848,29 +6319,30 @@ int input_poll(int getchar)
 			if (!time[i]) time[i] = GetTimer(af_delay[i]);
 			int send = 0;
 
+			if (CheckTimer(time[i]))
+			{
+				time[i] = GetTimer(af_delay[i]);
+				af[i] = !af[i];
+				if (joy[i] & autofire[i]) send = 1;
+			}
+
+			process_advanced_map(i, curr_frame, joy[i]);
 			int newdir = ((joy[i] & 0xF) != (joy_prev[i] & 0xF));
-			if (joy[i] != joy_prev[i])
+
+			if (autofire_new[i] != joy_prev[i])
 			{
-				if ((joy[i] ^ joy_prev[i]) & autofire[i])
+				send = 1;
+				if ((autofire_new[i] ^ joy_prev[i]) & autofire[i])
 				{
 					time[i] = GetTimer(af_delay[i]);
 					af[i] = 0;
 				}
-
-				send = 1;
-				joy_prev[i] = joy[i];
-			}
-
-			if (CheckTimer(time[i]))
-			{
-				time[i] = GetTimer(af_delay[i]);
-				af[i] = !af[i];
-				if (joy[i] & autofire[i]) send = 1;
+				joy_prev[i] = autofire_new[i];
 			}
 
 			if (send)
 			{
-				user_io_digital_joystick(i, af[i] ? joy[i] & ~autofire[i] : joy[i], newdir);
+				user_io_digital_joystick(i, af[i] ? autofire_new[i] & ~autofire[i] : autofire_new[i], newdir);
 			}
 		}
 	}
@@ -6030,3 +6502,210 @@ void parse_buttons()
 		joy_bcount++;
 	}
 }
+
+
+static void input_analog_save_filename(char *fname, size_t pathlen, int dev_num, bool def=false)
+{
+  char *id = get_unique_mapping(dev_num);
+
+	if (def || is_menu()) snprintf(fname, pathlen, "advanced_analog_%s%s_v3.map", id, input[dev_num].mod ? "_m" : "");
+	else snprintf(fname, pathlen, "%s_advanced_analog_%s%s_v3.map", user_io_get_core_name(), id, input[dev_num].mod ? "_m" : "");
+}
+
+static void input_advanced_save_filename(char *fname, size_t pathlen, int dev_num, bool def=false)
+{
+  char *id = get_unique_mapping(dev_num);
+
+	if (def || is_menu()) snprintf(fname, pathlen, "advanced_input_%s%s_v3.map", id, input[dev_num].mod ? "_m" : "");
+	else snprintf(fname, pathlen, "%s_advanced_input_%s%s_v3.map", user_io_get_core_name(), id, input[dev_num].mod ? "_m" : "");
+}
+
+void input_advanced_save(int dev_num)
+{
+	char path[256] = {JOYMAP_DIR};
+	char fname[256] = {};
+
+	if (dev_num >= 0)
+	{
+    int bufsize = sizeof(advancedButtonMap)*ADVANCED_MAP_MAX;
+		input_advanced_save_filename(fname, sizeof(fname), dev_num);
+		strncat(path, fname, sizeof(path)-1);
+		int saved = FileSaveConfig(path, input[dev_num].advanced_map, bufsize); 
+		bufsize = sizeof(input[dev_num].analogAxisMap);
+		input_analog_save_filename(fname, sizeof(fname), dev_num);
+		strcpy(path, JOYMAP_DIR);
+		strncat(path, fname, sizeof(path)-1);
+		saved = FileSaveConfig(path, input[dev_num].analogAxisMap, bufsize);
+		if (saved)
+		{
+			Info("Saved!");
+		} else {
+			Info("Error saving");
+		}
+	}
+}
+
+
+static void input_advanced_initialize(int player_num, int dev_num)
+{
+
+  devInput *inp = NULL;
+  advancedButtonMap *abm = NULL;
+
+  if (player_num)
+  {
+    inp = &player_pad[player_num];
+  } else if (dev_num >= 0 && dev_num < NUMDEV) {
+    inp = &input[dev_num];
+  }
+  if (!inp) return;
+
+  for(int i=0; i < ADVANCED_MAP_MAX; i++)
+  {
+    abm = &inp->advanced_map[i];
+		for (uint i = 0; i < sizeof(abm->bnum)/sizeof(abm->bnum[0]); i++)
+		{
+			abm->bnum[i] = -1;
+		}
+	}
+}
+
+void input_advanced_load(int dev_num)
+{
+	char path[256] = {JOYMAP_DIR};
+  int bufsize = sizeof(advancedButtonMap)*ADVANCED_MAP_MAX;
+	input_advanced_initialize(0, dev_num);
+	uint8_t *buf = new uint8_t[bufsize];
+	if (buf)
+	{
+		memset(buf, 0, bufsize); 
+		char fname[256] = {};
+		input_advanced_save_filename(fname, sizeof(fname), dev_num, false); 
+		strncat(path, fname, sizeof(path)-1);
+		if (FileLoadConfig(path, buf, bufsize))
+		{
+			memcpy(input[dev_num].advanced_map, buf, bufsize); 
+		}
+		delete[](buf);
+	}
+	//Load the sys buttons from main menu, add them to the end of the array
+	
+	buf = new uint8_t[bufsize];
+	strncpy(path, JOYMAP_DIR, sizeof(path));
+	if (buf)
+	{
+
+		memset(buf, 0, bufsize); 
+		char fname[256] = {};
+		input_advanced_save_filename(fname, sizeof(fname), dev_num, true); 
+		strncat(path, fname, sizeof(path)-1);
+		FileLoadConfig(path, buf, bufsize); 
+		memcpy(&input[dev_num].advanced_map[ADVANCED_MAP_MAX], buf, bufsize); 
+		delete[](buf);
+	}
+
+  input_advanced_sanitize(0, dev_num);
+
+	bufsize = sizeof(input[dev_num].analogAxisMap);
+
+	buf = new uint8_t[bufsize];
+	strncpy(path, JOYMAP_DIR, sizeof(path));
+	if (buf)
+	{
+		memset(buf, 0, bufsize);
+		char fname[256] = {};
+		input_analog_save_filename(fname, sizeof(fname), dev_num);
+		strncat(path, fname, sizeof(path)-1);
+		if (FileLoadConfig(path, buf, bufsize))
+		{
+			memcpy(input[dev_num].analogAxisMap, buf, bufsize);
+		}
+		delete[](buf);
+	}
+}
+
+void input_advanced_sanitize(int player_num, int dev_num)
+{
+
+  devInput *inp = NULL;
+  advancedButtonMap *abm = NULL;
+  if (player_num)
+  {
+    inp = &player_pad[player_num];
+  } else if (dev_num) {
+    inp = &input[dev_num];
+  }
+
+  if (!inp) return;
+
+  for(int i=0; i < ADVANCED_MAP_MAX; i++)
+  {
+    //If user defines any system functions, disable the global ones that match.
+    //If user binds any button (or combination of buttons) to a global one, disable the global
+    abm = &inp->advanced_map[i];
+
+    for (int j=0; j < ADVANCED_MAP_MAX; j++)
+    {
+      advancedButtonMap *sys_abm = &inp->advanced_map[ADVANCED_MAP_MAX+j];
+			for (uint b=0; b < sizeof(abm->bnum)/sizeof(abm->bnum[0]); b++)
+			{
+				int bnum = abm->bnum[b];
+				if (bnum < 0) break;
+      	if((bnum & 0xF0) && sys_abm->bnum == abm->bnum)
+      	{
+					for (uint sb=0; sb < sizeof(sys_abm->bnum)/sizeof(sys_abm->bnum[0]); b++)
+					{
+						int sbnum = sys_abm->bnum[sb];
+						if (sbnum < 0) break;
+						if (sbnum == bnum) {
+        			sys_abm->codes[0] = 0;
+						}
+					}
+      	}
+			}
+
+      int s_len = 0; 
+      int a_len = 0;
+
+      while(sys_abm->codes[s_len]) s_len++;
+      while(abm->codes[a_len]) a_len++;
+
+      if (s_len == a_len)
+      {
+        bool code_match = true;
+        for (int a=0; a < a_len; a++)
+        {
+          int a_code = abm->codes[a];
+          for (int s=0; s < s_len; s++)
+          {
+            int s_code = sys_abm->codes[s];
+            if (s_code != a_code)
+            {
+              code_match = false;
+              break;
+            }
+          }
+          if (!code_match) break;
+        }
+        if (code_match) sys_abm->codes[0] = 0;
+      }
+    }
+  }
+
+  //Any binds in the 'old' style map that overlap with system binds: disable system bind
+  for (int i=0; i < ADVANCED_MAP_MAX; i++)
+  {
+    advancedButtonMap *sys_abm = &inp->advanced_map[ADVANCED_MAP_MAX+i];
+    if (!sys_abm->codes[0]) continue;
+    for(int j=0; j < NUMBUTTONS; j++)
+    {
+      if ((inp->map[j] & 0xFFFF) == sys_abm->codes[0] || (inp->map[j] >> 16) == sys_abm->codes[0])
+      {
+        sys_abm->codes[0] = 0;
+      }
+    }
+  }
+}
+
+
+
diff --git a/input.h b/input.h
index e89dc98..f0b8ce3 100644
--- a/input.h
+++ b/input.h
@@ -69,8 +69,38 @@
 #define SPIN_LEFT          30
 #define SPIN_RIGHT         31
 
+#define SYS_BTN_SCREENSHOT 0xF0 
+#define SYS_BTN_RESET 0xF1 
+#define SYS_BTN_SAVESTATE 0xF2 
+
+
 #define KEY_EMU (KEY_MAX+1)
 
+#define ADVANCED_MAP_MAX 16
+
+
+typedef enum
+{
+        BUTTON_ON = 0,
+        BUTTON_OFF, 
+        BUTTON_DELAY
+} advanced_button_state;
+
+
+typedef struct {
+        int bnum[8];
+				uint32_t keycodes[8];
+        uint32_t codes[8];
+        int on_frames;
+        int off_frames;
+        int delay_frames;
+        int cur_state_frames;
+        advanced_button_state button_state;
+        bool pressed;
+        int last_frame;
+				bool last_pressed;
+} advancedButtonMap;
+
 void set_kbdled(int mask, int state);
 int  get_kbdled(int mask);
 int  toggle_kbdled(int mask);
@@ -104,6 +134,21 @@ int get_dev_num(int dev);
 int get_remap_spinner_value();
 int get_numplayers();
 
+
+void start_code_capture(int dnum, bool cancellable = false, bool keyboard = false);
+void end_code_capture();
+uint32_t get_captured_code();
+int get_last_input_dev();
+int get_dev_num(int dev);
+void input_autofire_save();
+void input_autofire_load();
+
+advancedButtonMap *get_advanced_map_defs(int devnum);
+void get_button_name_for_code(uint16_t btn_code, int devnum, char *bname, size_t bname_sz);
+void input_advanced_sanitize(int player_num, int dev_num);
+uint32_t *get_analog_remap_defs(int devnum);
+
+
 uint32_t get_key_mod();
 uint32_t get_ps2_code(uint16_t key);
 uint32_t get_amiga_code(uint16_t key);
@@ -123,5 +168,7 @@ extern uint8_t ps2_kbd_scan_set;
 void parse_buttons();
 char *get_buttons(int type = 0);
 void set_ovr_buttons(char *s, int type);
+void input_advanced_save(int player_num);
+void input_advanced_load(int dev_num);
 
 #endif
diff --git a/menu.cpp b/menu.cpp
index ec2ffc8..e65643a 100644
--- a/menu.cpp
+++ b/menu.cpp
@@ -64,6 +64,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "bootcore.h"
 #include "ide.h"
 #include "profiling.h"
+#include "str_util.h"
 
 /*menu states*/
 enum MENU
@@ -200,6 +201,19 @@ enum MENU
 	// MT32-pi
 	MENU_MT32PI_MAIN1,
 	MENU_MT32PI_MAIN2,
+
+	//Advanced Button Map
+	MENU_ADVANCED_MAP_LIST1,
+	MENU_ADVANCED_MAP_LIST2,
+	MENU_ADVANCED_MAP_EDIT1,
+	MENU_ADVANCED_MAP_EDIT2,
+	MENU_ADVANCED_MAP_EDIT3,
+	MENU_ADVANCED_MAP_EDIT4,
+	MENU_ADVANCED_MAP_CAPTURE1,
+	MENU_ADVANCED_ANALOG_LIST1,
+	MENU_ADVANCED_ANALOG_CAPTURE1,
+	MENU_ADVANCED_MAP_KEYCAPTURE1
+
 };
 
 static uint32_t menustate = MENU_NONE1;
@@ -293,6 +307,11 @@ static uint32_t fs_Options;
 static uint32_t fs_MenuSelect;
 static uint32_t fs_MenuCancel;
 
+static int abm_edit_idx = -1;
+static int analog_capture_idx = -1;
+static int abm_dev_num = 0;
+static uint32_t abm_edit_codes[8] = {};
+
 static char* GetExt(char *ext)
 {
 	static char extlist[32];
@@ -469,6 +488,29 @@ void SelectINI()
 	select_ini = 1;
 }
 
+
+void build_advanced_map_code_str(uint32_t *abm_codes, size_t abm_size, char *code_str, size_t code_size)
+{
+					strncat(code_str, "[", code_size);
+					for (unsigned int i = 0; i < abm_size/sizeof(uint32_t); i++)
+					{
+						char cs[64] = {};
+						if (!abm_codes[i]) break;
+						if (abm_codes[i] < 256) //keyboard
+						{
+							sprintfz(cs, "%X", abm_codes[i]);
+						} else {
+            	get_button_name_for_code(abm_codes[i], abm_dev_num, cs, sizeof(cs));
+						}
+            strncat(cs, ",", sizeof(cs)-1);
+						strncat(code_str, cs, code_size);
+					}
+					int code_len = strlen(code_str);
+					if (code_str[code_len-1] == ',') code_str[code_len-1] = 0;
+					strcat(code_str, "]");
+}
+
+
 /* the Atari core handles OSD keys competely inside the core */
 static uint32_t menu_key = 0;
 
@@ -925,6 +967,66 @@ static int gun_idx = 0;
 static int32_t gun_pos[4] = {};
 static int page = 0;
 
+
+static void menu_button_name(int button, char *buf, size_t bsize)
+{
+	switch(button)
+	{
+	        case 0:
+	                strncpy(buf, "Right", bsize);
+	                break;
+	        case 1:
+	                strncpy(buf, "Left", bsize);
+	                break;
+	        case 2:
+	                strncpy(buf, "Down", bsize);
+	                break;
+	        case 3:
+	                strncpy(buf, "Up", bsize);
+	                break;
+					case 0xF0:
+									strncpy(buf, "Screenshot", bsize);
+									break;
+					case 0xF1:
+								  strncpy(buf, "Reset", bsize);
+									break;
+					case 0xF2: 
+									strncpy(buf, "Savestate(sys)", bsize);
+									break;
+					case -1:
+									strncpy(buf, "(None)", bsize);
+									break;
+	        default:
+	                if ((button-4 < joy_bcount) && joy_bnames[button-4][0])
+	                {
+	                        strncpy(buf, joy_bnames[button-4], bsize);
+	                } else {
+	                        snprintf(buf, bsize, "%d", button-4);
+	                }
+	}
+}
+
+
+static void menu_parse_buttons()
+{
+	if (is_minimig())
+	{
+		joy_bcount = 7;
+		strcpy(joy_bnames[0], "A(Red/Fire)");
+		strcpy(joy_bnames[1], "B(Blue)");
+		strcpy(joy_bnames[2], "C(Yellow)");
+		strcpy(joy_bnames[3], "D(Green)");
+		strcpy(joy_bnames[4], "RT");
+		strcpy(joy_bnames[5], "LT");
+		strcpy(joy_bnames[6], "Pause");
+	}
+	else
+	{
+		parse_buttons();
+  }
+}
+
+
 void HandleUI(void)
 {
 	PROFILE_FUNCTION();
@@ -996,6 +1098,8 @@ void HandleUI(void)
 
 	mgl_struct *mgl = mgl_get();
 
+  static unsigned long advanced_save_timer;
+
 	/*
 	static int old_state = -1;
 	static int old_current = -1;
@@ -1129,9 +1233,9 @@ void HandleUI(void)
 	{
 		switch (c)
 		{
-		case KEY_F12:
+		case KEY_F12 | UPSTROKE:
 			menu = true;
-			menu_key_set(KEY_F12 | UPSTROKE);
+			//menu_key_set(KEY_F12 | UPSTROKE);
 			if(video_fb_state()) video_menu_bg(user_io_status_get("[3:1]"));
 			video_fb_enable(0);
 			break;
@@ -2540,7 +2644,7 @@ void HandleUI(void)
 			while(1)
 			{
 				n = 0;
-				menumask = 0x7805d;
+				menumask = 0x780bd;
 
 				if (!menusub) firstmenu = 0;
 				adjvisible = 0;
@@ -2561,6 +2665,7 @@ void HandleUI(void)
 				MenuWrite(n++, s, menusub == 2, 0);
 				MenuWrite(n++, " Button/Key remap          \x16", menusub == 3, 0);
 				MenuWrite(n++, " Change player assignment", menusub == 4, 0);
+        MenuWrite(n++, " Advanced Mapping          \x16", menusub == 5, 0);
 
 				if (user_io_get_uart_mode())
 				{
@@ -2572,11 +2677,11 @@ void HandleUI(void)
 					sprintf(s, " UART mode (%s)            ",p);
 					s[27] = '\x16';
 					s[28] = 0;
-					MenuWrite(n++, s, menusub == 5);
+					MenuWrite(n++, s, menusub == 6);
 				}
 
 				MenuWrite(n++);
-				MenuWrite(n++, " Video processing          \x16", menusub==6);
+				MenuWrite(n++, " Video processing          \x16", menusub==7);
 
 				if (audio_filter_en() >= 0)
 				{
@@ -2696,14 +2801,21 @@ void HandleUI(void)
         menusub = 0;
 				break;
 
-			case 5:
+      case 5:
+        abm_dev_num = get_last_input_dev();
+        menustate = MENU_ADVANCED_MAP_LIST1;
+        menusub = 0;
+        advanced_save_timer = 0;
+        break;
+
+			case 6:
 				{
 					menustate = MENU_UART1;
 					menusub = 0;
 				}
 				break;
 
-			case 6:
+			case 7:
 				{
 					menustate = MENU_VIDEOPROC1;
 					menusub = 0;
@@ -3055,6 +3167,590 @@ void HandleUI(void)
 		}
 		break;
 
+
+	case MENU_ADVANCED_MAP_LIST1:
+	{
+			OsdSetTitle("Advanced");
+			menu_parse_buttons();
+			menustate = MENU_ADVANCED_MAP_LIST2;
+			parentstate = MENU_ADVANCED_MAP_LIST1;
+			abm_dev_num = get_last_input_dev();
+      firstmenu = 0;
+
+			advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+			menumask = 0x7;
+			uint32_t menucnt = 0;
+			MenuWrite(0, " Analog Axis Remap", menusub == menucnt++, 0);
+			MenuWrite(1, " New                       \x16", menusub == menucnt++, 0);
+      if (!advanced_save_timer || CheckTimer(advanced_save_timer))
+      {
+			  MenuWrite(2, " Save                      \x16", menusub == menucnt++, 0);
+        advanced_save_timer = 0;
+      } else {
+        MenuWrite(2, " Saved!                    \x16", menusub == menucnt++, 0);
+      }
+
+			int n = 3;
+			char bname[32] = {};
+			for(int i = 0; i < 16; i++)
+			{
+				advancedButtonMap *abm = abms+i;
+				bool has_autofire = abm->on_frames && abm->off_frames;
+				if (abm->codes[0])
+ 				{
+					int mapped_button_cnt = 0;
+					int first_map_idx = -1;
+					for (uint bn = 0; bn < sizeof(abm->bnum)/sizeof(abm->bnum[0]); bn++)
+					{
+						if (abm->bnum[bn] != -1) 
+						{
+							mapped_button_cnt++;
+							if (first_map_idx == -1)
+							{
+								first_map_idx = bn;
+							}
+						}
+					}
+					for (uint bn = 0; bn < sizeof(abm->keycodes)/sizeof(abm->keycodes[0]); bn++)
+					{
+						if (abm->keycodes[bn]) 
+						{
+							mapped_button_cnt++;
+						}
+					}
+
+					if (mapped_button_cnt > 1)
+					{
+						sprintfz(bname, "(%d)", mapped_button_cnt);
+					} else {
+						menu_button_name(abm->bnum[0], bname, sizeof(bname));
+					}
+					char code_str[256] = {};
+					build_advanced_map_code_str(abm->codes, sizeof(abm->codes), code_str, sizeof(code_str));
+					if (has_autofire)
+					{
+						sprintf(s, " %s->%s [%d Hz]", code_str, bname, 60 / (abm->on_frames + abm->off_frames));
+					} else {
+						sprintf(s, " %s->%s", code_str, bname);			
+					}
+					s[27] = '\x16';
+					s[28] = 0;
+					menumask |= 1<<menucnt;
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+				}
+      }
+	 		for (; n < OsdGetSize() - 1; n++) MenuWrite(n, "", 0, 0);
+			break;
+	}
+
+			case MENU_ADVANCED_MAP_LIST2:
+				{
+					if (select)
+					{
+						advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+						abm_edit_idx = -1;
+						analog_capture_idx = -1;
+						menustate = MENU_ADVANCED_MAP_EDIT1;
+						parentstate = MENU_ADVANCED_MAP_LIST1;
+						if (menusub == 0)
+						{
+							menustate = MENU_ADVANCED_ANALOG_LIST1;
+						} else if (menusub == 1) {
+							//New, find suitable slot
+
+							for (int i = 0; i < 16; i++)
+								{
+									advancedButtonMap *abm = abms+i;
+									if (!abm->codes[0])
+									{
+										abm_edit_idx = i;
+										break;
+									}
+								}
+
+							if (is_menu())
+							{
+								(abms+abm_edit_idx)->bnum[0] = SYS_BTN_SCREENSHOT;
+							}
+						} else if (menusub == 2) {
+							input_advanced_save(abm_dev_num);
+              advanced_save_timer  = GetTimer(2000);
+							menustate = MENU_ADVANCED_MAP_LIST1;
+						} else {
+							abm_edit_idx = menusub -3;
+						}
+					}
+
+					if (left || back || menu)
+					{
+						menustate = is_menu() ? MENU_SYSTEM1 : MENU_COMMON1;
+						parentstate = 0;
+					}
+					break;
+				}
+
+			case MENU_ADVANCED_ANALOG_LIST1:
+				{
+					parentstate = MENU_ADVANCED_ANALOG_LIST1;
+					uint32_t *analogRemaps = get_analog_remap_defs(abm_dev_num);
+					int n = 0;
+					uint32_t menucnt = 0;
+					char as[64] = {};
+
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Left Stick X+       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Left Stick X-       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Left Stick Y+       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Left Stick Y-       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Right Stick X+       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Right Stick X-       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Right Stick Y+       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+					menumask |= 1<<menucnt;
+					if (analogRemaps[menucnt] >= KEY_EMU)
+          	get_button_name_for_code(analogRemaps[menucnt], abm_dev_num, as, sizeof(as));
+					sprintfz(s, " Right Stick Y-       %s", as);
+					MenuWrite(n++, s, menusub ==  menucnt++, 0);
+					as[0] = 0;
+	 				for (; n < OsdGetSize() - 1; n++) MenuWrite(n, "", 0, 0);
+
+					if (left || back || menu)
+					{
+						menustate = MENU_ADVANCED_MAP_LIST1;
+						parentstate = 0;
+					} else if (select) {
+						menustate = MENU_ADVANCED_ANALOG_CAPTURE1;
+						analog_capture_idx = menusub;
+						start_code_capture(abm_dev_num, true);
+						MenuWrite(menusub, "Capturing... ", true, 0);
+					}
+					break;
+				}
+
+
+			case MENU_ADVANCED_ANALOG_CAPTURE1:
+				{
+					uint32_t *analogRemaps = get_analog_remap_defs(abm_dev_num);
+					uint32_t captured_code = get_captured_code();
+					if (captured_code == 0xFFFFFFFF)
+					{
+						analogRemaps[analog_capture_idx] = 0;
+						menustate = MENU_ADVANCED_ANALOG_LIST1;
+						end_code_capture();
+					} else { 
+						captured_code &= 0x0000FFFF;
+						if (captured_code >= KEY_EMU)
+						{
+							analogRemaps[analog_capture_idx] = captured_code;
+							menustate = MENU_ADVANCED_ANALOG_LIST1;
+							end_code_capture();
+						}
+					}
+					break;
+				}
+
+			case MENU_ADVANCED_MAP_EDIT1:
+				{
+
+					menustate = MENU_ADVANCED_MAP_EDIT2;
+					parentstate = MENU_ADVANCED_MAP_EDIT1;
+					firstmenu = 0;
+					adjvisible = 0;
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					int mapped_button_cnt = 0;
+					int first_map_idx = -1;
+					for (uint bn = 0; bn < sizeof(edit_abm->bnum)/sizeof(edit_abm->bnum[0]); bn++)
+					{
+						if (edit_abm->bnum[bn] != -1) 
+						{
+							mapped_button_cnt++;
+							if (first_map_idx == -1)
+							{
+								first_map_idx = bn;
+							}
+						}
+					}
+
+					if (!edit_abm->on_frames)
+					{
+						edit_abm->on_frames = 1;
+					}
+
+					menu_parse_buttons();
+					char bname[32] = {};
+					if (mapped_button_cnt == 1 || mapped_button_cnt == 0)
+					{
+						
+						menu_button_name(mapped_button_cnt ? edit_abm->bnum[first_map_idx] : -1, bname, sizeof(bname));
+					} else if (mapped_button_cnt) {
+						sprintfz(bname, "(%d)", mapped_button_cnt);
+					}
+
+					bool has_autofire = edit_abm->on_frames && edit_abm->off_frames;
+					menumask = 0x18F;
+					if (has_autofire)
+					{
+						menumask |= 0x70;
+					}
+					uint32_t n = 0;
+					char code_str[256] = {};
+					build_advanced_map_code_str(edit_abm->keycodes, sizeof(edit_abm->keycodes), code_str, sizeof(code_str));
+					snprintf(s, sizeof(s), " Button: %-17s\x10 \x11", bname);
+					MenuWrite(n, s, menusub == n, 0); n++;
+					snprintf(s, sizeof(s), " Keyboard: %-20s\x16", code_str);
+					MenuWrite(n, s, menusub == n, 0); n++;
+					code_str[0] = 0;
+					build_advanced_map_code_str(edit_abm->codes, sizeof(edit_abm->codes), code_str, sizeof(code_str));
+					snprintf(s, sizeof(s), " Hotkey %-20s\x16",code_str);
+					MenuWrite(n, s, menusub == n, 0); n++;
+					snprintf(s, sizeof(s), " Autofire: %s", has_autofire ? "ON" : "OFF");
+					MenuWrite(n, s, menusub == n, 0); n++;
+					snprintf(s, sizeof(s), " On Frames  %-14d\x10 \x11", edit_abm->on_frames);
+					MenuWrite(n, s, menusub == n, !has_autofire); n++;
+					sprintf(s, " Off Frames %-14d\x10 \x11", edit_abm->off_frames);
+					MenuWrite(n, s, menusub == n, !has_autofire); n++;
+          sprintf(s, " Delay Frames %-12d\x10 \x11", edit_abm->delay_frames);
+          MenuWrite(n, s, menusub == n, !has_autofire); n++;
+					MenuWrite(n, " Delete", menusub == n, 0); n++;
+					MenuWrite(n, " Done", menusub == n, 0); n++;
+					for (int i = n; i < OsdGetSize() - 1; i++) MenuWrite(i, "", 0, 0);
+					break;
+				}
+
+			case MENU_ADVANCED_MAP_EDIT2:
+				{
+					if (select || left || right)
+					{
+						menustate = MENU_ADVANCED_MAP_EDIT1;
+						advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+						advancedButtonMap *edit_abm = abms+abm_edit_idx;
+						bool has_autofire = edit_abm->on_frames && edit_abm->off_frames;
+            char bname[32] = {0};
+						switch(menusub)
+							{
+								case 0:
+									{
+										int mapped_button_cnt = 0;
+										int first_map_idx = -1;
+										for (uint bn = 0; bn < sizeof(edit_abm->bnum)/sizeof(edit_abm->bnum[0]); bn++)
+										{
+											if (edit_abm->bnum[bn] != -1) 
+											{
+												mapped_button_cnt++;
+												if (first_map_idx == -1)
+												{
+													first_map_idx = bn;
+												}
+											}
+										}
+										if (select) 
+										{
+											menustate = MENU_ADVANCED_MAP_EDIT3;
+										} else if (right && (mapped_button_cnt <= 1)) {
+											if (first_map_idx == -1) first_map_idx = 0;
+											edit_abm->bnum[first_map_idx]++;
+					        	  menu_button_name(edit_abm->bnum[first_map_idx], bname, sizeof(bname));
+                  	  while(!strncmp("-", bname, sizeof(bname)))
+                  	  {
+                  	    edit_abm->bnum[first_map_idx]++;
+                  	    menu_button_name(edit_abm->bnum[first_map_idx], bname, sizeof(bname));
+                  	  }
+											if (edit_abm->bnum[first_map_idx]-4 >= joy_bcount)
+											{
+												if (edit_abm->bnum[first_map_idx] < SYS_BTN_SCREENSHOT) edit_abm->bnum[first_map_idx] = SYS_BTN_SCREENSHOT;
+												if (edit_abm->bnum[first_map_idx] > SYS_BTN_SAVESTATE) edit_abm->bnum[first_map_idx] = is_menu() ? SYS_BTN_SCREENSHOT : 0;
+											}
+										} else if (left && (mapped_button_cnt <= 1)) {
+											if (first_map_idx == -1) first_map_idx = 0;
+											edit_abm->bnum[first_map_idx]--;
+					        	  menu_button_name(edit_abm->bnum[first_map_idx], bname, sizeof(bname));
+                  	  while(!strncmp("-", bname, sizeof(bname)))
+                  	  {
+                  	    edit_abm->bnum[first_map_idx]--;
+                  	    menu_button_name(edit_abm->bnum[first_map_idx], bname, sizeof(bname));
+                  	  }
+											if (edit_abm->bnum[first_map_idx] < 0) edit_abm->bnum[first_map_idx] = SYS_BTN_SAVESTATE;
+											if (edit_abm->bnum[first_map_idx] < SYS_BTN_SCREENSHOT && edit_abm->bnum[first_map_idx]-4 >= joy_bcount) edit_abm->bnum[first_map_idx] = is_menu() ? SYS_BTN_SAVESTATE : joy_bcount+3;
+										}
+
+										break;
+									}
+								case 1: 
+									if (select) {
+										menustate = MENU_ADVANCED_MAP_KEYCAPTURE1;
+										memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+										start_code_capture(abm_dev_num, false, true);
+									}
+									break;
+								case 2:
+									if (select) {
+										menustate = MENU_ADVANCED_MAP_CAPTURE1;
+										memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+										start_code_capture(abm_dev_num);
+									}
+									break;
+								
+								case 3: 
+									if (select)
+									{
+										if (has_autofire)
+										{
+											edit_abm->off_frames = edit_abm->on_frames = 0;
+										} else {
+											edit_abm->off_frames = edit_abm->on_frames = 1;
+										}
+									}
+									break;
+								case 4:
+									if (select || right)
+									{
+										edit_abm->on_frames++;
+									} else if (left) {
+										edit_abm->on_frames--;
+									}
+
+									if (edit_abm->on_frames < 0)
+									{
+										edit_abm->on_frames = 0;
+									}
+									break;
+								case 5:
+									if (select || right)
+									{
+										edit_abm->off_frames++;
+									} else if (left) {
+										edit_abm->off_frames--;
+									}
+									if (edit_abm->off_frames < 0)
+									{
+										edit_abm->off_frames = 0;
+									}
+									break;
+                case 6:
+									if (select || right)
+									{
+										edit_abm->delay_frames++;
+									} else if (left) {
+										edit_abm->delay_frames--;
+									}
+									if (edit_abm->delay_frames < 0)
+									{
+										edit_abm->delay_frames = 0;
+									}
+									break;
+								case 7:
+									if (select)
+									{
+										menustate = MENU_ADVANCED_MAP_LIST1;
+										edit_abm->codes[0] = 0;
+										edit_abm->on_frames = 0;
+										edit_abm->off_frames = 0;
+										for(uint i = 0; i < sizeof(edit_abm->bnum)/sizeof(edit_abm->bnum[0]); i++) edit_abm->bnum[i] = -1;
+									}
+									break;
+								case 8:
+									if (select)
+									{
+										menustate = MENU_ADVANCED_MAP_LIST1;
+									}
+									break;
+							}
+					}
+
+					if (back || menu)
+					{
+						menustate = MENU_ADVANCED_MAP_LIST1;
+						menusub = 0;
+					}
+					break;
+				}
+			case MENU_ADVANCED_MAP_EDIT3:
+				{
+					menustate = MENU_ADVANCED_MAP_EDIT4;
+					parentstate = MENU_ADVANCED_MAP_EDIT3;
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					while (1) {
+						menumask = 0;
+						uint32_t n = 0;
+						if (!menusub) firstmenu = 0;
+						adjvisible = 0;
+						for (int i = 0; i < joy_bcount+4; i++)
+						{
+
+							char bname[32];
+							menu_button_name(i, bname, sizeof(bname));
+							if (!strcmp("-", bname)) continue;
+							bool b_used = false;
+							for (uint bi = 0; bi < sizeof(edit_abm->bnum)/sizeof(edit_abm->bnum[0]); bi++ )
+							{
+								if (edit_abm->bnum[bi] == i) {
+									b_used = true;
+									break;
+								}
+							}
+							sprintfz(s, "%s %s", b_used ? "*":" ", bname);	
+							MenuWrite(n, s, menusub == n, 0); 
+							menumask |= 1<<n;
+							n++;
+						}
+						if (!adjvisible) break;
+						firstmenu += adjvisible;
+					}
+					break;
+				}
+			case MENU_ADVANCED_MAP_EDIT4:
+				{
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					if (back || menu) 
+					{
+						menustate = MENU_ADVANCED_MAP_EDIT1;
+						menusub = 0;
+					} else if (select) {
+						menustate = MENU_ADVANCED_MAP_EDIT3;
+						int map_slot = -1;
+						int first_avail = -1;
+						for (uint i = 0; i < sizeof(edit_abm->bnum)/sizeof(edit_abm->bnum[0]); i++)
+						{
+							if (edit_abm->bnum[i] == -1 && first_avail == -1)
+							{
+								first_avail = i;
+							}
+							if (edit_abm->bnum[i] == (int)menusub)
+							{
+								map_slot = i;
+							}
+						}
+
+						if (map_slot > -1) //It is mapped, so remove it
+						{
+							edit_abm->bnum[map_slot] = -1;
+						} else if (first_avail > -1) {
+							edit_abm->bnum[first_avail] = menusub;
+						}
+					}
+					break;
+				}
+
+			case MENU_ADVANCED_MAP_CAPTURE1:
+				{
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					OsdSetTitle("Set Hotkey", 0);
+					for (int i = 0; i < 5; i++) OsdWrite(i, "", 0, 0);
+					OsdWrite(5, info_top, 0, 0);
+					infowrite(6, "Press input hotkey");
+					OsdWrite(7, info_bottom, 0, 0);
+					char code_str[256] = {};
+					build_advanced_map_code_str(abm_edit_codes, sizeof(abm_edit_codes), code_str, sizeof(code_str));
+					OsdWrite(10, code_str, 0, 0);
+
+					uint32_t captured_code = get_captured_code();
+					if (captured_code)
+					{
+						uint code_idx = 0;
+						bool is_captured = false;
+						uint8_t pressed = (captured_code & 0x80000000) >> 28 ;
+						captured_code &= 0x0000FFFF;
+						while(abm_edit_codes[code_idx] && code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0]))
+					  {
+								if (abm_edit_codes[code_idx] == captured_code) is_captured = true;
+								code_idx++;
+						}
+						if (!is_captured && pressed && (code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0])))
+						{
+							abm_edit_codes[code_idx] = captured_code;
+						}
+						if (!pressed && is_captured)  
+						{
+							end_code_capture();
+							menustate = MENU_ADVANCED_MAP_EDIT1;
+							memcpy(edit_abm->codes, abm_edit_codes, sizeof(edit_abm->codes));
+              input_advanced_sanitize(0, abm_dev_num);
+						} else {
+							menustate = MENU_ADVANCED_MAP_CAPTURE1;
+						}
+
+					}
+					break;
+				}
+			case MENU_ADVANCED_MAP_KEYCAPTURE1:
+				{
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					OsdSetTitle("Set Hotkey", 0);
+					for (int i = 0; i < 5; i++) OsdWrite(i, "", 0, 0);
+					OsdWrite(5, info_top, 0, 0);
+					infowrite(6, "Press keyboard key");
+					OsdWrite(7, info_bottom, 0, 0);
+					char code_str[256] = {};
+					build_advanced_map_code_str(abm_edit_codes, sizeof(abm_edit_codes), code_str, sizeof(code_str));
+					OsdWrite(10, code_str, 0, 0);
+
+					uint32_t captured_code = get_captured_code();
+					if (captured_code)
+					{
+						uint code_idx = 0;
+						bool is_captured = false;
+						uint8_t pressed = (captured_code & 0x80000000) >> 28 ;
+						captured_code &= 0x0000FFFF;
+						while(abm_edit_codes[code_idx] && code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0]))
+					  {
+								if (abm_edit_codes[code_idx] == captured_code) is_captured = true;
+								code_idx++;
+						}
+						if (!is_captured && pressed && (code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0])))
+						{
+							abm_edit_codes[code_idx] = captured_code;
+						}
+						if (!pressed && is_captured)  
+						{
+							end_code_capture();
+							menustate = MENU_ADVANCED_MAP_EDIT1;
+							memcpy(edit_abm->keycodes, abm_edit_codes, sizeof(edit_abm->keycodes));
+              input_advanced_sanitize(0, abm_dev_num);
+						} else {
+							menustate = MENU_ADVANCED_MAP_KEYCAPTURE1;
+						}
+
+					}
+					break;
+				}
 	case MENU_DOC_FILE_SELECTED:
 		if (cfg.fb_terminal)
 		{
@@ -6520,7 +7216,7 @@ void HandleUI(void)
 
 		m = 0;
 		OsdSetTitle("System Settings", OSD_ARROW_LEFT);
-		menumask = 0x7F;
+		menumask = 0xFF;
 
 		OsdWrite(m++);
 		sprintf(s, "       MiSTer v%s", version + 5);
@@ -6571,17 +7267,18 @@ void HandleUI(void)
 		OsdWrite(m++, "");
 		OsdWrite(m++, " Remap keyboard            \x16", menusub == 1);
 		OsdWrite(m++, " Define joystick buttons   \x16", menusub == 2);
-		OsdWrite(m++, " Scripts                   \x16", menusub == 3);
-		OsdWrite(m++, " Help                      \x16", menusub == 4);
+		OsdWrite(m++, " Advanced Buttons          \x16", menusub == 3);
+		OsdWrite(m++, " Scripts                   \x16", menusub == 4);
+		OsdWrite(m++, " Help                      \x16", menusub == 5);
 		OsdWrite(m++, "");
 		cr = m;
-		OsdWrite(m++, " Reboot (hold \x16 cold reboot)", menusub == 5);
+		OsdWrite(m++, " Reboot (hold \x16 cold reboot)", menusub == 6);
 		sysinfo_timer = 0;
 
 		reboot_req = 0;
 
 		while(m < OsdGetSize()-1) OsdWrite(m++, "");
-		OsdWrite(15, STD_EXIT, menusub == 6);
+		OsdWrite(15, STD_EXIT, menusub == 7);
 		menustate = MENU_SYSTEM2;
 		break;
 
@@ -6610,6 +7307,10 @@ void HandleUI(void)
 				break;
 
 			case 3:
+				menustate = MENU_ADVANCED_MAP_LIST1;
+				break;
+
+			case 4:
 				{
 					uint8_t confirm[32] = {};
 					int match = 0;
@@ -6636,13 +7337,13 @@ void HandleUI(void)
 				}
 				break;
 
-			case 4:
+			case 5:
 				strcpy(Selected_tmp, DOCS_DIR);
 				FileCreatePath(Selected_tmp);
 				SelectFile(Selected_tmp, "PDFTXTMD ", SCANO_DIR | SCANO_TXT, MENU_DOC_FILE_SELECTED, MENU_NONE1);
 				break;
 
-			case 5:
+			case 6:
 				{
 					reboot_req = 1;
 
@@ -6655,7 +7356,7 @@ void HandleUI(void)
 				}
 				break;
 
-			case 6:
+			case 7:
 				menustate = MENU_NONE1;
 				break;
 			}
diff --git a/scaler.cpp b/scaler.cpp
index d04ad1b..f601c96 100644
--- a/scaler.cpp
+++ b/scaler.cpp
@@ -149,3 +149,28 @@ int mister_scaler_read_32(mister_scaler *ms, unsigned char *gbuf) {
 
     return 0;
 }
+
+
+int mister_scaler_frame_counter(mister_scaler *ms)
+{
+  if (!ms)
+  {
+          return 0;
+  }
+
+
+  volatile unsigned char *buffer = (unsigned char *)(ms->map+ms->map_off);
+	volatile unsigned char fc1, fc2, fc3, fc4, fc5;
+	//The scaler updates each header for the triple buffers separately, so we need to grab all of them
+	//Stupid: the headers can be at either base+0x200000/0x400000 or 0x800000/0x1000000
+	//since ram isn't on core loads, the headers (other than the frame counter) may look the same as 'used' ones
+	//even though they aren't. just use all of them. unused extra buffers will not change
+	//Each frame counter is three bits.
+	fc1 = (buffer[5]>>5) & 0x07;
+	fc2 = (buffer[0x200005]>>5) & 0x07;
+	fc3 = (buffer[0x400005]>>5) & 0x07;
+	fc4 = (buffer[0x800005]>>5) & 0x07;
+	fc5 = (buffer[0x1000005]>>5) & 0x07;
+  return (fc1 | (fc2 << 3) | (fc3 << 6) | (fc4 << 9) | (fc5 << 12));
+}
+
diff --git a/scaler.h b/scaler.h
index 3eb4084..e354f4b 100644
--- a/scaler.h
+++ b/scaler.h
@@ -20,12 +20,13 @@ typedef struct {
 } mister_scaler;
 
 #define MISTER_SCALER_BASEADDR     0x20000000
-#define MISTER_SCALER_BUFFERSIZE   2048*3*1024
+#define MISTER_SCALER_BUFFERSIZE   2048*3*4096
 
 mister_scaler *mister_scaler_init();
 int mister_scaler_read(mister_scaler *,unsigned char *buffer);
 int mister_scaler_read_32(mister_scaler *ms, unsigned char *buffer);
 int mister_scaler_read_yuv(mister_scaler *ms,int,unsigned char *y,int, unsigned char *U,int, unsigned char *V);
 void mister_scaler_free(mister_scaler *);
+int mister_scaler_frame_counter(mister_scaler *ms);
 
 #endif
diff --git a/user_io.cpp b/user_io.cpp
index 1c099ad..0a56296 100644
--- a/user_io.cpp
+++ b/user_io.cpp
@@ -3930,7 +3930,7 @@ void user_io_kbd(uint16_t key, int press)
 				if (key == KEY_MENU) key = KEY_F12;
 				if (key != KEY_F12 || !block_F12)
 				{
-					if (osd_is_visible) menu_key_set(UPSTROKE | key);
+					/*if (osd_is_visible) */ menu_key_set(UPSTROKE | key);
 
 					// these modifiers should be passed to core even if OSD is open or they will get stuck!
 					if (!osd_is_visible || key == KEY_LEFTALT || key == KEY_RIGHTALT || key == KEY_LEFTMETA || key == KEY_RIGHTMETA) send_keycode(key, press);
@@ -3943,14 +3943,14 @@ void user_io_kbd(uint16_t key, int press)
 				if (!osd_is_visible && !is_menu() && key == KEY_MENU && press == 3) open_joystick_setup();
 				else if ((has_menu() || osd_is_visible || (get_key_mod() & (LALT | RALT | RGUI | LGUI))) && (((key == KEY_F12) && ((!is_x86() && !is_pcxt() && !is_archie()) || (get_key_mod() & (RGUI | LGUI)))) || key == KEY_MENU))
 				{
-					block_F12 = 1;
+					//block_F12 = 1;
 					if (press == 1) menu_key_set(KEY_F12);
 				}
 				else if (osd_is_visible)
 				{
 					if (key == KEY_MENU) key = KEY_F12;
-					if (key == KEY_F12) block_F12 = 1;
-					if (press == 1) menu_key_set(key);
+					//if (key == KEY_F12) block_F12 = 1;
+					if (press == 1 ) menu_key_set(key);
 				}
 				else
 				{
-- 
2.43.0

