From 3be77e4fd52c873c41503f0ba26c0a4c5b47f151 Mon Sep 17 00:00:00 2001
From: Zakk <zakk@rsdio.com>
Date: Wed, 14 Jan 2026 02:42:08 -0500
Subject: [PATCH 04/11] 0004

---
 gamecontroller_db.cpp |  14 +-
 gamecontroller_db.h   |   1 +
 input.cpp             | 716 +++++++++++++++++++++++++++++++++++----
 input.h               |  36 ++
 menu.cpp              | 766 +++++++++++++++++++++++++++++++++++++++---
 user_io.cpp           |  15 +-
 user_io.h             |   2 +-
 7 files changed, 1428 insertions(+), 122 deletions(-)

diff --git a/gamecontroller_db.cpp b/gamecontroller_db.cpp
index fab15ec..d229820 100644
--- a/gamecontroller_db.cpp
+++ b/gamecontroller_db.cpp
@@ -195,14 +195,15 @@ static int find_linux_code_for_button(char *btn_name, uint16_t *btn_map, uint16_
 #define test_bit(bit, array)  (array [bit / 8] & (1 << (bit % 8)))
 
 
-static void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint16_t *abs_map)
+void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint16_t *abs_map)
 {
 	unsigned char keybits[(KEY_MAX+7) / 8];
 	unsigned char absbits[(ABS_MAX+7) / 8];
 	uint16_t btn_cnt = 0;
 	uint16_t abs_cnt = 0;
 
-	printf("Gamecontrollerdb: mapping buttons for %s ", guid);
+	if (guid)
+  	printf("Gamecontrollerdb: mapping buttons for %s ", guid);
 	if (ioctl(dev_fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits) >= 0)
 	{
 		for (int i = BTN_JOYSTICK; i < KEY_MAX; i++)
@@ -223,11 +224,13 @@ static void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint1
 					btn_cnt++;
 				}
 		}
-		printf("\n");
+		if (guid)
+		  printf("\n");
 
 	}
 
-	printf("Gamecontrollerdb: mapping analog axes for %s ", guid);
+	if (guid)
+	  printf("Gamecontrollerdb: mapping analog axes for %s ", guid);
 	if (ioctl(dev_fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits) >= 0)
 	{
 		//The "correct" way is to test  all the way to ABS_MAX and skip any hats the device has.
@@ -253,7 +256,8 @@ static void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint1
 				}
 		}
 	}
-	printf("\n");
+	if(guid)
+	  printf("\n");
 }
 
 void gcdb_show_string_for_ctrl_map(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version,int dev_fd, const char *name, uint32_t *cur_map)
diff --git a/gamecontroller_db.h b/gamecontroller_db.h
index 0010c58..42540aa 100644
--- a/gamecontroller_db.h
+++ b/gamecontroller_db.h
@@ -11,6 +11,7 @@
 
 bool gcdb_map_for_controller(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version, int dev_fd, uint32_t *fill_map);
 void gcdb_show_string_for_ctrl_map(uint16_t bustype, uint16_t vid, uint16_t pid, uint16_t version,int dev_fd, const char *name, uint32_t *cur_map);
+void get_ctrl_index_maps(int dev_fd, char *guid, uint16_t *btn_map, uint16_t *abs_map);
 #endif
 
 
diff --git a/input.cpp b/input.cpp
index 49cbf0d..e08adac 100644
--- a/input.cpp
+++ b/input.cpp
@@ -37,6 +37,9 @@
 #define NUMPLAYERS 6
 #define UINPUT_NAME "MiSTer virtual input"
 
+bool update_advanced_state(int devnum, uint16_t evcode, int evstate, int osd_event);
+bool osd_inhibit_next_release = false;
+
 char joy_bnames[NUMBUTTONS][32] = {};
 int  joy_bcount = 0;
 static struct pollfd pool[NUMDEV + 3];
@@ -1082,6 +1085,9 @@ static int ev2archie[] =
 	NONE  //255 ???
 };
 
+static uint32_t af_lastcode[NUMPLAYERS];
+static uint64_t af_lastmask[NUMPLAYERS];
+
 uint8_t ps2_kbd_scan_set = 2;
 uint32_t get_ps2_code(uint16_t key)
 {
@@ -1150,8 +1156,6 @@ typedef struct
 
 	uint8_t  has_mmap;
 	uint32_t mmap[NUMBUTTONS];
-	uint8_t  has_jkmap;
-	uint16_t jkmap[1024];
 	int      stick_l[2];
 	int      stick_r[2];
 
@@ -1205,6 +1209,10 @@ typedef struct
 	float    max_range[2];
 
 	uint32_t deadzone;
+	advancedButtonMap advanced_map[ADVANCED_MAP_MAX];
+	advancedButtonState advanced_state[ADVANCED_MAP_MAX];
+	bool has_advanced_map;
+	bool is_keyboard;
 } devInput;
 
 static devInput input[NUMDEV] = {};
@@ -1401,12 +1409,18 @@ static int mapping_set;
 static int mapping_current_key = 0;
 static int mapping_current_dev = -1;
 
+static bool ev_capturing = false;
+static int ev_capture_dnum = -1;
+static uint16_t captured_ev_code = 0;
+static bool ev_capture_seen_press = false;
+uint8_t ev_capture_osd = 0;
+static int last_input_dev = 1<<31;
+
 static uint32_t tmp_axis[4];
 static int tmp_axis_n = 0;
 
 static int grabbed = 1;
 
-static int last_input_dev = 1<<31;
 static int last_pdsp_dev = 1<<31;
 static int player_num_remapping = 0;
 static int remapping_spinner_input = 0;
@@ -1588,11 +1602,6 @@ void finish_map_setting(int dismiss)
 		if (dismiss) FileDeleteConfig(get_kbdmap_name(mapping_dev));
 		else FileSaveConfig(get_kbdmap_name(mapping_dev), &input[mapping_dev].kbdmap, sizeof(input[mapping_dev].kbdmap));
 	}
-	else if (mapping_type == 3)
-	{
-		if (dismiss) memset(input[mapping_dev].jkmap, 0, sizeof(input[mapping_dev].jkmap));
-		save_map(get_jkmap_name(mapping_dev), &input[mapping_dev].jkmap, sizeof(input[mapping_dev].jkmap));
-	}
 	else
 	{
 		for (int i = 0; i < NUMDEV; i++)
@@ -1711,12 +1720,15 @@ static int keyrah_trans(int key, int press)
 	return key;
 }
 
-static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int dev);
+static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int dev, bool reinjected = false);
 
 static int kbd_toggle = 0;
 static uint64_t joy[NUMPLAYERS] = {};		// 0-31 primary mappings, 32-64 alternate
 static uint64_t autofire[NUMPLAYERS] = {};	// 0-31 primary mappings, 32-64 alternate
+static uint32_t advancedautofire[NUMPLAYERS] = {};
 static uint32_t autofirecodes[NUMPLAYERS][BTN_NUM] = {};
+static uint32_t joy_adv[NUMPLAYERS] = {};
+static uint32_t joy_adv_af[NUMPLAYERS] = {};
 static int af_delay[NUMPLAYERS] = {};
 
 static uint32_t crtgun_timeout[NUMDEV] = {};
@@ -1738,7 +1750,7 @@ static uint32_t mouse_timer = 0;
 #define BTN_TGL 100
 #define BTN_OSD 101
 
-#define AF_MIN  16
+#define AF_MIN  17 
 #define AF_MAX  512
 #define AF_STEP 8
 
@@ -1910,12 +1922,25 @@ static void joy_apply_deadzone(int* x, int* y, const devInput* dev, const int st
 	joy_clamp(y, min_range, INT8_MAX);
 }
 
+static void send_autofire_msg(int pnum, bool enable)
+{
+	char str[128];
+
+
+	if (hasAPI1_5())
+	{
+		if (enable) sprintf(str, "Auto fire: %dms (%uhz)", af_delay[pnum] * 2, 1000 / (af_delay[pnum] * 2));
+		else sprintf(str, "Auto fire: OFF");
+		Info(str);
+	}
+	else InfoMessage((enable) ? "\n\n          Auto fire\n             ON" :
+									"\n\n          Auto fire\n             OFF");
+}
+
+
 static uint32_t osdbtn = 0;
 static void joy_digital(int jnum, uint64_t mask, uint32_t code, char press, int bnum, int dont_save = 0)
 {
-	static char str[128];
-	static uint32_t lastcode[NUMPLAYERS];
-	static uint64_t lastmask[NUMPLAYERS];
 	int num = jnum - 1;
 	if (num < NUMPLAYERS)
 	{
@@ -1927,13 +1952,13 @@ static void joy_digital(int jnum, uint64_t mask, uint32_t code, char press, int
 				{
 					if (press)
 					{
-						lastcode[num] = code;
-						lastmask[num] = mask;
+						af_lastcode[num] = code;
+						af_lastmask[num] = mask;
 					}
 					else
 					{
-						lastcode[num] = 0;
-						lastmask[num] = 0;
+						af_lastcode[num] = 0;
+						af_lastmask[num] = 0;
 					}
 				}
 			}
@@ -1941,14 +1966,15 @@ static void joy_digital(int jnum, uint64_t mask, uint32_t code, char press, int
 			{
 				if (!user_io_osd_is_visible() && press && !cfg.disable_autofire)
 				{
-					if (lastcode[num] && lastmask[num])
+					if (!(af_lastcode[num] & 0x8000) && (af_lastcode[num] & 0x7FFF) && af_lastmask[num])
 					{
+						osd_inhibit_next_release = true;
 						int found = 0;
 						int zero = -1;
 						for (uint i = 0; i < BTN_NUM; i++)
 						{
 							if (!autofirecodes[num][i]) zero = i;
-							if (autofirecodes[num][i] == lastcode[num])
+							if (autofirecodes[num][i] == af_lastcode[num])
 							{
 								found = 1;
 								autofirecodes[num][i] = 0;
@@ -1956,31 +1982,22 @@ static void joy_digital(int jnum, uint64_t mask, uint32_t code, char press, int
 							}
 						}
 
-						if (!found && zero >= 0) autofirecodes[num][zero] = lastcode[num];
-						
-						autofire[num] = !found ? autofire[num] | lastmask[num] : autofire[num] & ~lastmask[num];
-
-						if (hasAPI1_5())
-						{
-							if (!found) sprintf(str, "Auto fire: %dms (%uhz)", af_delay[num] * 2, 1000 / (af_delay[num] * 2));
-							else sprintf(str, "Auto fire: OFF");
-							Info(str);
-						}
-						else InfoMessage((!found) ? "\n\n          Auto fire\n             ON" :
-							"\n\n          Auto fire\n             OFF");
-
+						if (!found && zero >= 0) autofirecodes[num][zero] = af_lastcode[num];
+						autofire[num] = !found ? autofire[num] | af_lastmask[num] : autofire[num] & ~af_lastmask[num];
+            send_autofire_msg(num, !found);
 						return;
 					}
-					else if (lastmask[num] & 0xF)
+					else if (af_lastmask[num] & 0xF)
 					{
-						if (lastmask[num] & 9)
+						osd_inhibit_next_release = true;
+						if (af_lastmask[num] & 9)
 						{
-							af_delay[num] += AF_STEP << ((lastmask[num] & 1) ? 1 : 0);
+							af_delay[num] += AF_STEP << ((af_lastmask[num] & 1) ? 1 : 0);
 							if (af_delay[num] > AF_MAX) af_delay[num] = AF_MAX;
 						}
 						else
 						{
-							af_delay[num] -= AF_STEP << ((lastmask[num] & 2) ? 1 : 0);
+							af_delay[num] -= AF_STEP << ((af_lastmask[num] & 2) ? 1 : 0);
 							if (af_delay[num] < AF_MIN) af_delay[num] = AF_MIN;
 						}
 
@@ -2145,10 +2162,13 @@ static void joy_digital(int jnum, uint64_t mask, uint32_t code, char press, int
 				break;
 
 			default:
-				ev.code = (bnum == BTN_OSD) ? KEY_MENU : 0;
+				ev.code = (bnum == BTN_OSD && !osd_inhibit_next_release) ? KEY_MENU : 0;
+				if ((bnum == BTN_OSD) && !press)
+				{
+						osd_inhibit_next_release = false;
+				}
 			}
-
-			input_cb(&ev, 0, 0);
+			input_cb(&ev, 0, 0, true);
 		}
 		else if (video_fb_state())
 		{
@@ -2206,7 +2226,10 @@ static void joy_digital(int jnum, uint64_t mask, uint32_t code, char press, int
 			{
 				int found = 0;
 				for (uint i = 0; i < BTN_NUM; i++) if (autofirecodes[num][i] == code) found = 1;
-				if (found) autofire[num] = press ? autofire[num] | mask : autofire[num] & ~mask;
+				if (found) 
+				{
+					autofire[num] = press ? autofire[num] | mask : autofire[num] & ~mask;
+				}
 			}
 		}
 	}
@@ -2447,7 +2470,6 @@ static void restore_player(int dev)
 				input[input[dev].bind].map_shown = player[k].map_shown;
 			}
 
-			memcpy(input[dev].jkmap, player[k].jkmap, sizeof(input[dev].jkmap));
 			input[dev].lightgun = player[k].lightgun;
 			break;
 		}
@@ -2613,7 +2635,7 @@ static void assign_player(int dev, int num, int force = 0)
 	printf("Device %s %sassigned to player %d\n", input[dev].id, force ? "forcebly " : "", input[dev].num);
 }
 
-static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int dev)
+static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int dev, bool reinjected)
 {
 	if (ev->type != EV_KEY && ev->type != EV_ABS && ev->type != EV_REL) return;
 	if (ev->type == EV_KEY && (!ev->code || ev->code == KEY_UNKNOWN)) return;
@@ -2625,6 +2647,68 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 	//check if device is a part of multifunctional device
 	if (!JOYCON_COMBINED(dev) && input[dev].bind >= 0) dev = input[dev].bind;
 
+	if (!reinjected)
+	{
+	  if (ev_capturing && ev->value && ev->type == EV_KEY)
+	  {
+	  	ev_capture_seen_press = true;
+
+	  }
+
+
+
+	  if (ev_capturing && ev_capture_seen_press && (ev_capture_dnum == sub_dev || ev->code <=256) && ev->type == EV_KEY)
+	  {
+	  	captured_ev_code = ev->code;
+
+			uint8_t old_osd = ev_capture_osd;
+			if (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL]) //Keyboard menu key
+			{
+				if (ev->value)
+					ev_capture_osd |= 0x4;
+				else
+					ev_capture_osd &= ~0x4;
+			}
+
+			if (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL+1])
+			{
+				if (ev->value)
+					ev_capture_osd |= 0x1;
+				else
+					ev_capture_osd &= ~0x1;
+
+			}
+
+      if (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL+2])
+			{
+				if (ev->value)
+					ev_capture_osd |= 0x2;
+				else
+					ev_capture_osd &= ~0x2;
+			}
+
+			if (ev->code == (input[dev].mmap[SYS_BTN_MENU_FUNC] & 0xFFFF))
+			{
+				captured_ev_code |= 0x2000;
+			}
+
+			if ((ev_capture_osd == 3) || (ev_capture_osd == 4))
+			{
+				captured_ev_code |= 0x4000;
+			} else if ((old_osd == 3 || old_osd == 4) && old_osd != ev_capture_osd ){
+				captured_ev_code |= 0x4000;
+			}
+
+			
+	  	if (ev->value)
+	  	{
+	  		captured_ev_code |= 0x8000;
+	  	}
+
+	  	return;
+	  }
+	}
+
 	if (ev->type == EV_KEY)
 	{
 		if (input[dev].timeout > 0) input[dev].timeout = cfg.bt_auto_disconnect * 10;
@@ -2756,13 +2840,10 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 		input[dev].has_map++;
 	}
 
-	if (!input[dev].has_jkmap)
+	if (!input[dev].has_advanced_map)
 	{
-		if (!load_map(get_jkmap_name(dev), &input[dev].jkmap, sizeof(input[dev].jkmap)))
-		{
-			memset(input[dev].jkmap, 0, sizeof(input[dev].jkmap));
-		}
-		input[dev].has_jkmap = 1;
+		input_advanced_load(dev);
+		input[dev].has_advanced_map = true;
 	}
 
 	if (!input[dev].num)
@@ -2998,9 +3079,6 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 				{
 					if (ev->value == 1)
 					{
-						// Technically it's hard to map the key to button as keyboards
-						// are all the same while joysticks are personalized and numbered.
-						input[mapping_dev].jkmap[mapping_button] = ev->code;
 						mapping_current_dev = dev;
 					}
 
@@ -3261,8 +3339,11 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 		switch (ev->type)
 		{
 		case EV_KEY:
-			if (ev->code < 1024 && input[dev].jkmap[ev->code] && !user_io_osd_is_visible()) ev->code = input[dev].jkmap[ev->code];
 
+      if (!reinjected)
+      {
+         last_input_dev = sub_dev;
+      }
 			//joystick buttons, digital directions
 			/*
 			if (player_num_remapping && input[dev].num)
@@ -3283,8 +3364,8 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 				}
 				else
 				{
-					if (osd_event == 1) joy_digital(input[dev].num, 0, 0, 1, BTN_OSD);
-					if (osd_event == 2) joy_digital(input[dev].num, 0, 0, 0, BTN_OSD);
+					if (osd_event == 1 && !reinjected) joy_digital(input[dev].num, 0, 0, 1, BTN_OSD);
+					if (osd_event == 2 && !reinjected) joy_digital(input[dev].num, 0, 0, 0, BTN_OSD);
 				}
 
 				if (user_io_osd_is_visible() || video_fb_state())
@@ -3433,11 +3514,14 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 						else if (ev->code == (input[dev].map[i] >> 16)) mask = (uint64_t)1 << (i + 32); // 1 is uint32_t. i spent hours realizing this.
 						if (mask) {
 							if (i <= 3 && origcode == ev->code) origcode = 0; // prevent autofire for original dpad
-							if (ev->value <=1) joy_digital(input[dev].num, mask, origcode, ev->value, i, (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 1] || ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 2]));
+							if (ev->value <=1) joy_digital(input[dev].num, mask, reinjected ? 0 : origcode, ev->value, i, (ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 1] || ev->code == input[dev].mmap[SYS_BTN_OSD_KTGL + 2]) || reinjected);
 							// support 2 simultaneous functions for 1 button if defined in 2 sets. No return.
 						}
 					}
 
+					if (!reinjected)
+							update_advanced_state(dev,  ev->code, ev->value, osd_event);
+
 					if (ev->code == input[dev].mmap[SYS_MS_BTN_EMU] && (ev->value <= 1) && ((!(mouse_emu & 1)) ^ (!ev->value)))
 					{
 						mouse_emu = ev->value ? mouse_emu | 1 : mouse_emu & ~1;
@@ -3478,6 +3562,11 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 				if (ev->code == 111) reset_m |= 0x100;
 				user_io_check_reset(reset_m, (keyrah && !cfg.reset_combo) ? 1 : cfg.reset_combo);
 
+				bool send_key = true;
+				if (ev->value <= 1 && !reinjected)
+				{
+				  send_key = update_advanced_state(dev,  ev->code, ev->value, osd_event);
+				}
 				if(!user_io_osd_is_visible() && ((user_io_get_kbdemu() == EMU_JOY0) || (user_io_get_kbdemu() == EMU_JOY1)) && !video_fb_state())
 				{
 					if (!kbd_toggle)
@@ -3562,7 +3651,7 @@ static void input_cb(struct input_event *ev, struct input_absinfo *absinfo, int
 				}
 
 				if (ev->code == KEY_HOMEPAGE) ev->code = KEY_MENU;
-				user_io_kbd(ev->code, ev->value);
+				if (send_key) user_io_kbd(ev->code, ev->value);
 				return;
 			}
 			break;
@@ -3833,6 +3922,7 @@ void mergedevs()
 
 									input[i].unique_hash = str_hash(input[i].id);
 									input[i].unique_hash = str_hash(input[i].mac, input[i].unique_hash);
+									input[i].is_keyboard = strstr(handlers, "kbd") ? true : false;
 
 									input[i].timeout = (strlen(uniq) && strstr(sysfs, "bluetooth")) ? (cfg.bt_auto_disconnect * 10) : 0;
 								}
@@ -3874,6 +3964,7 @@ void mergedevs()
 				if (!strcmp(input[i].id, input[j].id))
 				{
 					input[i].bind = j;
+					input[j].is_keyboard = input[i].is_keyboard;
 					break;
 				}
 			}
@@ -5253,6 +5344,7 @@ int input_test(int getchar)
 
 		while (1)
 		{
+			
 			if (cfg.rumble && !is_menu())
 			{
 				for (int i = 0; i < NUMDEV; i++)
@@ -5267,6 +5359,7 @@ int input_test(int getchar)
 				}
 			}
 
+
 			int return_value = poll(pool, NUMDEV + 3, timeout);
 			if (!return_value) break;
 
@@ -5292,7 +5385,6 @@ int input_test(int getchar)
 			{
 				int i = pos;
 
-
 				if ((pool[i].fd >= 0) && (pool[i].revents & POLLIN))
 				{
 					if (!input[i].mouse)
@@ -5934,6 +6026,8 @@ int input_poll(int getchar)
 	static int af[NUMPLAYERS] = {};
 	static uint32_t time[NUMPLAYERS] = {};
 	static uint64_t joy_prev[NUMPLAYERS] = {};
+	static uint32_t joy_adv_prev[NUMPLAYERS] = {};
+	static uint32_t send_prev[NUMPLAYERS] = {};
 
 	int ret = input_test(getchar);
 	if (getchar) return ret;
@@ -5975,10 +6069,10 @@ int input_poll(int getchar)
 			if (af_delay[i] < AF_MIN) af_delay[i] = AF_MIN;
 
 			/* Autofire handler */
-			if (joy[i] & autofire[i])
+			if ((joy[i] & autofire[i]) || (joy_adv[i] != joy_adv_af[i]))
 			{
 				if (!time[i]) time[i] = GetTimer(af_delay[i]);
-				else if ((joy[i] ^ joy_prev[i]) & autofire[i])
+				else if (((joy[i] ^ joy_prev[i]) & autofire[i]) || ((joy_adv[i] ^ joy_adv_prev[i]) & ~joy_adv_af[i]))
 				{
 					time[i] = GetTimer(af_delay[i]);
 					af[i] = 0;
@@ -5987,22 +6081,22 @@ int input_poll(int getchar)
 				{
 					time[i] = GetTimer(af_delay[i]);
 					af[i] = !af[i];
-					send = 1;
 				}
 			}
 
-			int newdir = ((((uint32_t)(joy[i]) | (uint32_t)(joy[i] >> 32)) & 0xF) != (((uint32_t)(joy_prev[i]) | (uint32_t)(joy_prev[i] >> 32)) & 0xF));
-
-			if (joy[i] != joy_prev[i])
-			{
+			uint64_t joy_send = af[i] ? joy[i] & ~autofire[i] : joy[i];
+			//uint32_t adv_send = af[i] ? joy_adv[i] & ~advancedautofire[i] : joy_adv[i];
+      uint32_t adv_send = af[i] ? joy_adv_af[i] : joy_adv[i];
+			uint32_t send_comb = (uint32_t)joy_send | (uint32_t)(joy_send >> 32) | adv_send;
+			int newdir = (send_comb & 0xF) != (send_prev[i] & 0x0F);
+			if (send_comb != send_prev[i]) 
+ 			{
+				user_io_digital_joystick(i, send_comb, newdir);
+				send_prev[i] = send_comb;
 				joy_prev[i] = joy[i];
-				send = 1;
-			}
+				joy_adv_prev[i] = joy_adv[i];
+ 			}
 
-			if (send)
-			{
-				user_io_digital_joystick(i, af[i] ? joy[i] & ~autofire[i] : joy[i], newdir);
-			}
 		}
 	}
 
@@ -6161,3 +6255,485 @@ void parse_buttons()
 		joy_bcount++;
 	}
 }
+
+
+static void advanced_convert_jkmap(int devnum)
+{
+
+  int abmidx = 0;
+
+  uint16_t jkmap[1024];
+  if (load_map(get_jkmap_name(devnum), jkmap, sizeof(jkmap)))
+	{
+	  for(size_t i = 0; i < sizeof(jkmap)/sizeof(jkmap[0]); i++)
+    {
+		  if (jkmap[i])
+		  {
+			  advancedButtonMap *abm = &input[devnum].advanced_map[abmidx++];
+		    memset(abm, 0, sizeof(advancedButtonMap));	
+			  abm->input_codes[0] = i;
+			  abm->output_codes[0] = jkmap[i];
+		  }
+	  }
+  }
+}
+
+
+/*
+* Advanced button mapping
+* advanced button mapping augments the 'button/key remap' functionality with more features.
+* - chording (up to 4 buttons can be mapped to up to 4 outputs)
+* - controller button(s) -> controller button(s) (same controller)
+* - controller button(s) -> keyboard key(s)
+* - controller button(s) -> core button(s).
+* - keyboard key(s) -> keyboard key(s)
+* - keyboard key(s) -> core button(s) (if the core has enabled keyboard controller emulation)
+*
+* There is an additional mapping mode, accessed by holding down menu OK.
+* This mode allows mapping buttons/keys directly to the buttons defined in the core's
+* config string. 
+*
+* The OSD is now triggered on negative edge/release. This allows the OSD button(s) to be 
+* part of a chord. The OSD button(s) must be the _first_ button(s) pressed in the chord; this 
+* preserves the mister's autofire functionality.
+*
+* Advanced maps react to mister's autofire like any "normal" mapped button. 
+* Hold the chord and then press the OSD button(s) to enable autofire.
+*
+* Interaction with normal mister button mapping:
+*
+* Advanced maps override normal maps:
+* Normal mapping: button A -> core button 3
+* Advanced mapping: buttons A+B -> core button 5
+* If you have A held and then press B, button 3 will release and button 5 will activate.
+* If you then release button B, button 3 will now activate.
+*
+* Non-autofire buttons always win over autofire. If you have two mappings (normal or advanced)
+* mapped to the same button, but one is autofire and the other is not when pressed simultaneously you will get a steady button press.
+* If you release the non-autofire button autofire will resume for those buttons.
+*
+*
+*/
+
+//Called when an advanced button entry's 'pressed' state changes.
+//current_mask tracks which core buttons are activated when this entry is in a pressed state.
+//physical buttons can change core button state, so this function saves a copy of the current
+//core button state and then zeros it out to capture all possible changes even through physical
+//button maps.
+//Can't just set the mask directly once because of autofire
+//(advanced map buttons can be autofired like "normal" buttons and there can be overlap with non-autofire maps)
+static void process_abm_entry(advancedButtonMap *abm, advancedButtonState *abs, int devnum, int pnum)
+{
+	uint64_t joy_sav = 0;
+	if (pnum >= 0)
+	{
+		joy_sav = joy[pnum];
+		joy[pnum] = 0;
+	}
+	abs->last_pressed = abs->pressed;
+
+	if (pnum >= 0 && abs->pressed)
+		joy[pnum] |= abm->button_mask;
+
+	//Inject press/release events for every "physical" button/key this entry is mapped to
+	for (uint k = 0; k < sizeof(abm->output_codes)/sizeof(abm->output_codes[0]); k++)
+	{
+		if (abm->output_codes[k])
+		{
+			input_event ev;
+			ev.value = abs->pressed ? 1 : 0;
+			ev.code = abm->output_codes[k];
+			ev.type = EV_KEY;
+			int outdev = ev.code <= 256 ? 0 : devnum;
+			input_cb(&ev, NULL, outdev, true);
+		}
+	}
+	if (pnum >= 0)
+  {
+		abs->current_mask = (uint32_t)joy[pnum] | (uint32_t)(joy[pnum] >> 32);
+		joy[pnum] = joy_sav;
+	}
+}
+
+//Called anytime there is an input event, unless the event was a fake one sent by
+//the advanced mapping state code. (input_cb -> reinjected==true)
+//In this function we eventually reassert the state of _all_ advanced map entries for this input device.
+//This is because the final state needs to be the logical or of all the entries' current_mask values.
+//Entries can potentially overlap, so if one of them gets released the other (still pressed one) needs 
+//to ensure any buttons it maps to are still pressed.
+//This function determines if any advanced maps are pressed, and does some housekeeping
+//for some of the autofire masks.
+
+bool update_advanced_state(int devnum, uint16_t evcode, int evstate, int osd_event)
+{
+	bool allow_keysend = true;
+	bool code_is_osd_btn = (evcode == input[devnum].mmap[SYS_BTN_OSD_KTGL+1] || evcode == input[devnum].mmap[SYS_BTN_OSD_KTGL+2]);
+
+	//input dev 'num' is the player number: it is the 'natural' number. so player 1 -> num=1, player 2 -> num=2 etc.
+	//the core<->hps controller interface is zero-index based, so the 'real' player number is num-1.
+	//Keyboards are sent as num=0
+	//A core confstr can control if the core wants raw keyboard events, or if keyboards can just emulate a controller.
+	//There's a keyboard shortcut to change the keyboard between p1/p2 and that's what this check is doing.
+	int pnum = input[devnum].num -1;
+	if (!input[devnum].num) {
+		int kbd_emu = user_io_get_kbdemu();
+		if (kbd_emu == EMU_JOY0)
+			pnum = 0;
+		else if (kbd_emu == EMU_JOY1)
+			pnum = 1;
+	}
+
+	//'raw' keyboards don't have an entry in the joy_X and af/autofire_X arrays.
+	//So every time they need referencing/saving you have to check that pnum is valid...
+	if (pnum >= 0)
+	{
+		joy_adv[pnum] = 0;
+		joy_adv_af[pnum] = 0;
+	}
+
+
+	//The logic here starts with the assumption the button is pressed, and then flips the state if 
+	//the entry doesn't satisfy all the 'is pressed' conditions.
+	//The main condition is that the number of pressed buttons is equal to the number of valid input_codes set in the entry.
+	//There is a separate (not saved to disk) 'advanced button state' structure that tracks various things to help
+	//with runtime calculations.
+	//One of these is the input_state var, which is a mask that tracks if each input_code entry is pressed or not.
+	//Tracking the state means for any given input event, we can determine if the entry is pressed or not without additional
+	//lookups needed.
+	//An alternative approach would be to either have each input device track it's own state, or ask the kernel for the input device's
+	//full state. The former involves each input[] entry needing to store an additional ~96 bytes; latter requires an additional ioctl() round trip every
+	//input. Seems more efficient to just track an additional byte per entry..
+	
+	for (uint i = 0; i < ADVANCED_MAP_MAX; i++)
+	{
+		advancedButtonMap *abm = &input[devnum].advanced_map[i];
+		advancedButtonState *abs = &input[devnum].advanced_state[i];
+		bool chord_has_osd = false;
+		if (!abm->input_codes[0]) break;
+
+		bool is_pressed = true;
+
+		int code_cnt = 0;
+		int pressed_cnt = 0;
+
+		for (unsigned int j = 0; j < sizeof(abm->input_codes)/sizeof(abm->input_codes[0]); j++)
+		{
+			if (!abm->input_codes[j])
+        break;
+
+			if (abm->input_codes[j] == evcode)
+			{
+				if (evstate)
+					abs->input_state |= 1<<j;
+				else
+					abs->input_state &= ~(1<<j);
+			}
+			code_cnt++;
+			if (abs->input_state & 1<<j) pressed_cnt++; 
+			if (abm->input_codes[j] == input[devnum].mmap[SYS_BTN_OSD_KTGL+1] || abm->input_codes[j] == input[devnum].mmap[SYS_BTN_OSD_KTGL+2])
+				chord_has_osd = true;
+		}
+
+		if (code_cnt != pressed_cnt)
+			is_pressed = false;
+
+		//if a chord contains the OSD button(s) they have to be first, otherwise it might
+		//interfere with autofire chording. 
+		if (code_is_osd_btn && evstate && chord_has_osd && pressed_cnt > 1)
+			is_pressed = false;
+
+		//Advanced maps override normal maps. This means if an advanced mapping is pressed, we need to 'turn off'
+		//any of the buttons that are part of the advanced input buttons, and turn them back on when the advanced map 
+		//is not pressed.
+		//Example: User has used the normal mister mapping to map button A to core button 3
+		//There is also an advanced map that maps buttons A+B to core button 5
+		//If the user is holding button A, and then presses button B, the end result should be that just button 5 is pressed.
+		//So when the abm entry flips to pressed, this loop reinjects a release event for all the input buttons of the map
+		//This causes the 'normal' mapping to get released.
+		//When the advanced map is released (any of the input buttons are released) it reinjects a pressed event
+		//for all the remaining pressed buttons in it's input. Which turns them back on for 'normal' mapping.
+		//This also applies for button->keyboard maps, and keyboard->keyboard maps
+		if (is_pressed || (is_pressed != abs->last_pressed))
+		{
+			for(size_t cidx = 0; cidx < sizeof(abm->input_codes)/sizeof(abm->input_codes[0]); cidx++)
+			{
+				if (!is_pressed && !(abs->input_state & 1<<cidx))
+					continue;
+				input_event ev;
+				ev.value = !is_pressed;
+				ev.code = abm->input_codes[cidx];
+				ev.type = EV_KEY;
+				input_cb(&ev, NULL, devnum, true);
+			}
+		}
+
+		abs->last_pressed = abs->pressed;
+		abs->pressed = is_pressed; 
+
+		
+		if (abs->pressed && !abs->last_pressed) allow_keysend = false;
+
+		//Autofire trickery.
+		//Normal mapping use a few arrays to track autofire functionality.
+		//af_lastcode
+		//af_lastmask
+		//autofirecodes
+		//af_* track the last pressed button code and core button mask for that code.
+		//when the osd button is pressed if these are set it turns on autofire for that button.
+		//autofirecodes tracks what button codes have had autofire  activated.
+		//All of these operate on single buttons, so they can't be used as-is for advanced
+		//chord maps. 
+		//This code repurposes af_* to track the last pressed advanced map and then handles
+		//the OSD button event to enable autofire for that advanced map.
+		//The 0x8000 mask is just a way to make a quick check that this is an advanced entry and not a keycodes
+		//(keycodes don't go that high)
+		if (abs->pressed != abs->last_pressed) 
+		{
+  		process_abm_entry(abm, abs, devnum, pnum);
+      if (pnum >= 0)
+      {
+        af_lastcode[pnum] = abs->pressed ? 0x8000 | i : 0;
+        af_lastmask[pnum] = abs->pressed ? abs->current_mask : 0;
+      }
+		}
+
+		if (pnum >= 0)
+		{
+			if (osd_event == 1 && (af_lastcode[pnum] == (0x8000 | i)) && abs->pressed)
+			{
+				abs->autofire = !abs->autofire;
+        send_autofire_msg(pnum, abs->autofire);
+				osd_inhibit_next_release = true;
+			}
+			joy_adv[pnum] |= abs->current_mask;
+      if (!abs->autofire)
+        joy_adv_af[pnum] |= abs->current_mask; 
+		}
+	}
+
+	//If this return is true input_cb inhibits sending the keyboard event to the core. 
+	//Needed so the core doesn't see a keyboard event for the last key in a chord
+	//(or when a single key has been remapped)
+	return allow_keysend;
+}
+
+advancedButtonMap *get_advanced_map_defs(int devnum)
+{
+	if (devnum < 0 || devnum >= NUMDEV)
+	{
+		return NULL;
+	}
+	devnum = input[devnum].bind;
+	return input[devnum].advanced_map; 
+}
+
+bool device_is_keyboard(int devnum)
+{
+	return input[devnum].is_keyboard;
+}
+
+
+void get_button_name_for_code(uint16_t btn_code, int devnum, char *bname, size_t bname_sz)
+{
+	
+	static int last_devnum = -1;
+	static uint16_t btn_map[KEY_MAX - BTN_JOYSTICK] = {0};
+	static uint16_t abs_map[ABS_MAX] = {0};
+	int use_devnum = devnum;
+	if (devnum != last_devnum)
+	{
+		memset(btn_map, 0xFFFF, sizeof(btn_map));
+		memset(abs_map, 0xFFFF, sizeof(abs_map));
+		get_ctrl_index_maps(pool[use_devnum].fd, NULL, btn_map, abs_map);
+		last_devnum = devnum;
+	}
+
+  snprintf(bname, bname_sz, "??");
+  if (btn_code >= KEY_EMU) //hat/analog
+  {
+    bool is_max = btn_code & 0x1;
+    uint16_t axis_idx = (btn_code - KEY_EMU) >> 1;
+    if (axis_idx >= ABS_HAT0X && axis_idx <= ABS_HAT3Y)
+    {
+      uint8_t hat_num = (axis_idx - ABS_HAT0X)/2;
+      bool axis_is_y = (axis_idx - ABS_HAT0X)%2;
+      uint8_t hat_sub = 0;
+      if (axis_is_y)
+      {
+        hat_sub = is_max ? 4 : 1;
+      } else {
+        hat_sub = is_max ? 2 : 8;
+      }
+      if (hat_sub)
+      {
+        snprintf(bname,bname_sz, "h%d.%d", hat_num, hat_sub);
+      }
+    } else {
+      //Mister 'fake' analog digital inputs.
+      for(unsigned int j=0; j < sizeof(abs_map)/sizeof(uint16_t); j++)
+      {
+        if (abs_map[j] == axis_idx)
+        {
+          if (is_max)
+            snprintf(bname, bname_sz, "+a%d", j);
+          else
+            snprintf(bname, bname_sz, "-a%d", j);
+          break;
+        }
+      }
+    }
+  } else {
+    for(unsigned int j=0; j < sizeof(btn_map)/sizeof(uint16_t); j++)
+    {
+      if (btn_map[j] == 0xFFFF) break;
+      if (btn_map[j] == btn_code) {
+        snprintf(bname, bname_sz, "b%d", j);
+        break;
+      }
+    }
+  }
+}
+
+void start_code_capture(int dnum)
+{
+	ev_capture_dnum = dnum;
+	ev_capturing = true;
+	captured_ev_code = 0;
+	ev_capture_seen_press = false;
+	ev_capture_osd = 0;
+}
+
+void end_code_capture()
+{
+	ev_capturing = false;
+	captured_ev_code = 0;
+	ev_capture_seen_press = false;
+	ev_capture_dnum = -1;
+}
+
+uint16_t get_captured_code()
+{
+	return captured_ev_code;
+}
+
+int code_capture_osd_count()
+{
+	int dev = ev_capture_dnum;
+	if (!JOYCON_COMBINED(dev) && input[dev].bind >= 0) dev = input[dev].bind;
+	if (dev < 0)
+		return 0;
+	if (input[dev].mmap[SYS_BTN_OSD_KTGL+1] != input[dev].mmap[SYS_BTN_OSD_KTGL+2])
+	  return 2;
+	return 1;
+}
+
+
+static void input_advanced_save_filename(char *fname, size_t pathlen, int dev_num, bool def=false)
+{
+  char *id = get_unique_mapping(dev_num);
+
+	if (def || is_menu()) snprintf(fname, pathlen, "advanced_input_%s%s_v3.map", id, input[dev_num].mod ? "_m" : "");
+	else snprintf(fname, pathlen, "%s_advanced_input_%s%s_v3.map", user_io_get_core_name(), id, input[dev_num].mod ? "_m" : "");
+}
+
+void input_advanced_save(int dev_num)
+{
+	char path[256] = {JOYMAP_DIR};
+	char fname[256] = {};
+
+	if (dev_num >= 0)
+	{
+		dev_num = input[dev_num].bind;
+    int bufsize = sizeof(advancedButtonMap)*ADVANCED_MAP_MAX;
+		input_advanced_save_filename(fname, sizeof(fname), dev_num);
+		strncat(path, fname, sizeof(path)-1);
+		int saved = FileSaveConfig(path, input[dev_num].advanced_map, bufsize); 
+		if (saved)
+		{
+			Info("Saved!");
+		} else {
+			Info("Error saving");
+		}
+	}
+}
+
+void input_advanced_load(int dev_num)
+{
+	char path[256] = {JOYMAP_DIR};
+  int bufsize = sizeof(advancedButtonMap)*ADVANCED_MAP_MAX;
+	uint8_t *buf = new uint8_t[bufsize];
+	if (buf)
+	{
+		dev_num = input[dev_num].bind;
+		memset(buf, 0, bufsize); 
+		char fname[256] = {};
+		input_advanced_save_filename(fname, sizeof(fname), dev_num, false); 
+		strncat(path, fname, sizeof(path)-1);
+		if (FileLoadConfig(path, buf, bufsize))
+		{
+			memcpy(input[dev_num].advanced_map, buf, bufsize); 
+			for(int i = 0; i < ADVANCED_MAP_MAX; i++)
+			{
+				advancedButtonMap *abm = &input[dev_num].advanced_map[i];
+				if (!abm->input_codes[0]) break;
+			}
+		} else {
+			advanced_convert_jkmap(dev_num);
+		}
+		delete[](buf);
+	}
+}
+
+void input_advanced_check_save(int devnum, advancedButtonMap *abm)
+{
+  if (!abm) return;
+
+	if (abm->input_codes[0] && (abm->button_mask || abm->output_codes[0]))
+	{
+		input_advanced_save(devnum);
+	}
+}
+
+bool input_advanced_check_hotkeys(uint16_t *key_codes, size_t kc_cnt, int devnum)
+{
+  //Don't allow OSD button (or combo) or KEY_F12 to be redefined via advanced map.
+	for(size_t i = 0; i < kc_cnt; i++)
+	{
+		uint16_t kc = key_codes[i];
+		if (!kc && i != 0)
+		 return false; 
+		if (kc != input[devnum].mmap[SYS_BTN_OSD_KTGL] && kc != input[devnum].mmap[SYS_BTN_OSD_KTGL+1] && kc != input[devnum].mmap[SYS_BTN_OSD_KTGL+2] && kc != KEY_F12)
+		return true;
+  }
+	return false;
+}
+
+//If we stored them sorted we could just use memcmp....
+advancedButtonMap *input_advanced_find_match(uint16_t *input_codes, size_t code_count, advancedButtonMap *abm_start, size_t abm_count)
+{
+  for (size_t i = 0; i < abm_count; i++)
+	{
+		int match_count = 0;
+		int jcnt = 0;
+		int kcnt = 0;
+		advancedButtonMap *abm = abm_start+i;
+		if (!abm->input_codes[0]) return NULL;
+		for(size_t j = 0; j < code_count; j++)
+		{
+
+      uint16_t scode = input_codes[j];	
+			if (scode != 0) jcnt++;
+			kcnt = 0;
+			for(size_t k = 0; k < code_count; k++)
+			{
+        uint16_t acode = abm->input_codes[k];
+				if (acode != 0) kcnt++;
+				if (acode && acode == scode) match_count++;
+			}
+		}
+    
+		if ((jcnt == kcnt) && match_count == jcnt) return abm;
+	}
+	return NULL;
+}
+
diff --git a/input.h b/input.h
index e89dc98..16f7187 100644
--- a/input.h
+++ b/input.h
@@ -71,6 +71,27 @@
 
 #define KEY_EMU (KEY_MAX+1)
 
+
+#define ADVANCED_MAP_MAX 32 
+
+
+typedef struct {
+        uint32_t button_mask;
+				uint16_t output_codes[4];
+        uint16_t input_codes[4];
+} advancedButtonMap;
+
+
+typedef struct {
+
+	uint8_t input_state;
+	uint32_t current_mask;
+	uint8_t pressed : 1;
+	uint8_t last_pressed : 1;
+	uint8_t autofire : 1;
+} advancedButtonState;
+
+
 void set_kbdled(int mask, int state);
 int  get_kbdled(int mask);
 int  toggle_kbdled(int mask);
@@ -124,4 +145,19 @@ void parse_buttons();
 char *get_buttons(int type = 0);
 void set_ovr_buttons(char *s, int type);
 
+void start_code_capture(int dnum);
+void end_code_capture();
+uint16_t get_captured_code();
+int code_capture_osd_count();
+int get_last_input_dev();
+int get_dev_num(int dev);
+advancedButtonMap *get_advanced_map_defs(int devnum);
+void get_button_name_for_code(uint16_t btn_code, int devnum, char *bname, size_t bname_sz);
+bool device_is_keyboard(int devnum);
+void input_advanced_save(int player_num);
+void input_advanced_load(int dev_num);
+void input_advanced_check_save(int devnum, advancedButtonMap *abm);
+bool input_advanced_check_hotkeys(uint16_t *key_codes, size_t kc_size, int devnum);
+advancedButtonMap *input_advanced_find_match(uint16_t *input_codes, size_t code_count, advancedButtonMap *abm_start, size_t abm_count);
+
 #endif
diff --git a/menu.cpp b/menu.cpp
index 446a242..2040835 100644
--- a/menu.cpp
+++ b/menu.cpp
@@ -64,6 +64,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "bootcore.h"
 #include "ide.h"
 #include "profiling.h"
+#include "str_util.h"
 
 /*menu states*/
 enum MENU
@@ -204,6 +205,17 @@ enum MENU
 	// MT32-pi
 	MENU_MT32PI_MAIN1,
 	MENU_MT32PI_MAIN2,
+
+	//Advanced Button Map
+	MENU_ADVANCED_MAP_LIST1,
+	MENU_ADVANCED_MAP_LIST2,
+	MENU_ADVANCED_MAP_EDIT1,
+	MENU_ADVANCED_MAP_EDIT2,
+	MENU_ADVANCED_MAP_EDIT3,
+	MENU_ADVANCED_MAP_EDIT4,
+	MENU_ADVANCED_MAP_CAPTURE1,
+	MENU_ADVANCED_MAP_KEYCAPTURE1,
+  MENU_ADVANCED_MAP_CAPTURETIMEOUT
 };
 
 static uint32_t menustate = MENU_NONE1;
@@ -297,6 +309,12 @@ static uint32_t fs_Options;
 static uint32_t fs_MenuSelect;
 static uint32_t fs_MenuCancel;
 
+static int abm_edit_idx = -1;
+static advancedButtonMap abm_edit_map = {};
+static int abm_dev_num = 0;
+static uint16_t abm_edit_codes[4] = {};
+static int abm_clear_timer = 0;
+
 static char* GetExt(char *ext)
 {
 	static char extlist[32];
@@ -473,6 +491,36 @@ void SelectINI()
 	select_ini = 1;
 }
 
+void build_advanced_map_code_str(uint16_t *abm_codes, size_t abm_size, char *code_str, size_t code_size, int center_size = 0)
+{
+					char str[128] = {};
+					strncat(str, "[", code_size);
+					for (unsigned int i = 0; i < abm_size/sizeof(uint16_t); i++)
+					{
+						char cs[64] = {};
+						if (!abm_codes[i]) break;
+						if (abm_codes[i] < 256) //keyboard
+						{
+							sprintfz(cs, "k%X", abm_codes[i]);
+						} else {
+            	get_button_name_for_code((abm_codes[i] & 0x7FFF), abm_dev_num, cs, sizeof(cs));
+						}
+            strncat(cs, ",", sizeof(cs)-1);
+						strncat(str, cs, code_size);
+					}
+					int code_len = strlen(str);
+					if (str[code_len-1] == ',') str[code_len-1] = 0;
+					strcat(str, "]");
+	        if (center_size)
+		      {
+		        snprintf(code_str, code_size, "%*s%*s", (int)(center_size+strlen(str)/2), str, (int)(center_size+strlen(str)/2), " ");
+	        } else {
+		        snprintf(code_str, code_size, "%s", str);
+        	}
+	          
+}
+
+
 /* the Atari core handles OSD keys competely inside the core */
 static uint32_t menu_key = 0;
 
@@ -930,6 +978,55 @@ static int gun_idx = 0;
 static int32_t gun_pos[4] = {};
 static int page = 0;
 
+static void menu_button_name(int button, char *buf, size_t bsize)
+{
+	switch(button)
+	{
+	        case 0:
+	                strncpy(buf, "Right", bsize);
+	                break;
+	        case 1:
+	                strncpy(buf, "Left", bsize);
+	                break;
+	        case 2:
+	                strncpy(buf, "Down", bsize);
+	                break;
+	        case 3:
+	                strncpy(buf, "Up", bsize);
+	                break;
+					case -1:
+									strncpy(buf, "(None)", bsize);
+									break;
+	        default:
+	                if ((button-4 < joy_bcount) && joy_bnames[button-4][0])
+	                {
+	                        strncpy(buf, joy_bnames[button-4], bsize);
+	                } else {
+	                        snprintf(buf, bsize, "%d", button-4);
+	                }
+	}
+}
+
+
+static void menu_parse_buttons()
+{
+	if (is_minimig())
+	{
+		joy_bcount = 7;
+		strcpy(joy_bnames[0], "A(Red/Fire)");
+		strcpy(joy_bnames[1], "B(Blue)");
+		strcpy(joy_bnames[2], "C(Yellow)");
+		strcpy(joy_bnames[3], "D(Green)");
+		strcpy(joy_bnames[4], "RT");
+		strcpy(joy_bnames[5], "LT");
+		strcpy(joy_bnames[6], "Pause");
+	}
+	else
+	{
+		parse_buttons();
+  }
+}
+
 void HandleUI(void)
 {
 	PROFILE_FUNCTION();
@@ -994,6 +1091,7 @@ void HandleUI(void)
 	static int old_volume = 0;
 	static uint32_t lock_pass_timeout = 0;
 	static uint32_t menu_timeout = 0;
+	static uint32_t menu_timeoutstate = 0;
 
 	static char	cp_MenuCancel;
 
@@ -1134,9 +1232,9 @@ void HandleUI(void)
 	{
 		switch (c)
 		{
-		case KEY_F12:
+		case KEY_F12 | UPSTROKE:
 			menu = true;
-			menu_key_set(KEY_F12 | UPSTROKE);
+			//menu_key_set(KEY_F12 | UPSTROKE);
 			if(video_fb_state()) video_menu_bg(user_io_status_get("[3:1]"));
 			video_fb_enable(0);
 			break;
@@ -2440,8 +2538,10 @@ void HandleUI(void)
 					if (is_n64())
 					{
 						uint32_t n64_crc;
-						if (!n64_rom_tx(selPath, idx, load_addr, n64_crc)) Info("failed to load ROM");
-						else if (user_io_use_cheats() && !store_name) cheats_init(selPath, n64_crc);
+						if (!n64_rom_tx(selPath, idx, load_addr, n64_crc)) 
+                Info("failed to load ROM");
+						else if (user_io_use_cheats() && !store_name) 
+                cheats_init(selPath, n64_crc);
 					}
 					else if (is_c64() || is_c128())
 					{
@@ -2703,7 +2803,8 @@ void HandleUI(void)
 				break;
 
 			case 3:
-				start_map_setting(-1);
+				abm_dev_num = get_last_input_dev();
+				memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
 				menustate = MENU_JOYKBDMAP;
 				menusub = 0;
 				break;
@@ -4265,72 +4366,230 @@ void HandleUI(void)
 		break;
 
 	case MENU_JOYKBDMAP:
+	{
 		helptext_idx = 0;
 		menumask = 1;
 		menustate = MENU_JOYKBDMAP1;
 		parentstate = MENU_JOYKBDMAP;
 
+		abm_dev_num = get_last_input_dev();
+		memset(&abm_edit_map, 0, sizeof(abm_edit_map));
+		start_code_capture(abm_dev_num);
+
 		OsdSetTitle("Button/Key remap", 0);
 		for (int i = 0; i < 5; i++) OsdWrite(i, "", 0, 0);
 		OsdWrite(5, info_top, 0, 0);
 		infowrite(6, "Supported mapping:");
 		infowrite( 7, "");
-		infowrite( 8, "Button -> Key");
-		infowrite( 9, "Button -> Button same pad");
-		infowrite(10, "Key -> Key");
-		infowrite(11, "");
-		infowrite(12, "     Menu \x16 Finish ");
-		infowrite(13, "Menu-hold \x16 Clear  ");
+		infowrite( 8, " Button(s)/Key(s) -> Key(s)");
+		infowrite( 9, "Button(s) -> Button(s)");
+		infowrite(10, "");
+		if (device_is_keyboard(abm_dev_num))
+		{
+			infowrite(11, "    Tab \x16 Advanced ");
+			infowrite(12, "  Esc \x16 Finish ");
+			infowrite(13, "Enter \x16 Clear ");
+		} else {
+	    infowrite(11, "     OK-hold \x16 Advanced  ");
+		  infowrite(12, "     Menu \x16 Finish ");
+		  infowrite(13, "Menu-hold \x16 Clear  ");
+		}
 		OsdWrite(14, info_bottom, 0, 0);
 		OsdWrite(OsdGetSize() - 1, "           Cancel", menusub == 0, 0);
 		break;
+		}
 
 	case MENU_JOYKBDMAP1:
-		if (!get_map_button())
 		{
-			OsdWrite(1, " Press button/key to change", 0, 0);
-			if (get_map_vid())
+
+		advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+		uint code_idx = 0;
+		uint16_t captured_code = get_captured_code();
+		bool is_captured = false;
+		bool pressed = (captured_code & 0x8000);
+		bool is_osd = (captured_code & 0x4000);
+		bool is_ok = (captured_code & 0x2000);
+	  captured_code &= 0x3FF;
+
+		bool is_enter = captured_code == KEY_ENTER;
+		bool is_esc = captured_code == KEY_ESC;
+		bool is_tab = captured_code == KEY_TAB;
+
+
+		while(abm_edit_codes[code_idx] && code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0]))
+	  {
+		  if (abm_edit_codes[code_idx] == captured_code) is_captured = true;
+		    code_idx++;
+		}
+
+		if (!is_captured && pressed && (code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0])))
+		{
+			abm_edit_codes[code_idx] = captured_code;
+			if (code_idx > 0) abm_clear_timer = 0;
+		}
+
+
+		if (abm_edit_map.input_codes[0] && !abm_edit_codes[1] && is_tab && !pressed)
+		{
+
+			  memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+  		  menustate = MENU_ADVANCED_MAP_LIST1;
+			  end_code_capture();
+				break;
+		}
+
+
+	  if (!abm_edit_map.input_codes[0] && !abm_edit_codes[1] && is_ok && pressed)
+		{
+	    if (!abm_clear_timer)
 			{
-				OsdWrite(2, "", 0, 0);
-				sprintf(s, "    on device %04x:%04x", get_map_vid(), get_map_pid());
-				OsdWrite(3, s, 0, 0);
+        abm_clear_timer = GetTimer(5000);
+			} else if (CheckTimer(abm_clear_timer)) {
+			  abm_clear_timer = 0;
+			  memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+  		  menustate = MENU_ADVANCED_MAP_LIST1;
+			  end_code_capture();
+				break;
 			}
-			OsdWrite(OsdGetSize() - 1, " Enter \x16 Finish, Esc \x16 Clear", menusub == 0, 0);
 		}
-		else
+
+		if (abm_edit_map.input_codes[0] && abm_edit_map.output_codes[0])
 		{
-			if (get_map_button() <= 256)
+	   	advancedButtonMap *abm = input_advanced_find_match(abm_edit_codes, sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0]), abms, ADVANCED_MAP_MAX);
+			if (!abm)
 			{
-				OsdWrite(1, "     Press key to map to", 0, 0);
-				OsdWrite(2, "", 0, 0);
-				OsdWrite(3, "        on a keyboard", 0, 0);
+	      for (int i = 0; i < ADVANCED_MAP_MAX; i++)
+			  {
+		  	  abm = abms+i;
+		  	  if (!abm->input_codes[0])
+				  {
+					  break;
+				  }
+			  }
 			}
-			else
+			if (abm)
 			{
-				OsdWrite(1, "   Press button to map to", 0, 0);
-				OsdWrite(2, "      on the same pad", 0, 0);
-				OsdWrite(3, "    or key on a keyboard", 0, 0);
+	      memcpy(abm, &abm_edit_map, sizeof(abm_edit_map));
+			} else {
+			  menu_timeout = GetTimer(1000);
+			  OsdWrite(1);
+			  OsdWrite(2,  "      No map slots left!    ");
+			  OsdWrite(3);
+			  OsdWrite(OsdGetSize() - 1);
+				memset(&abm_edit_map, 0, sizeof(abm_edit_map));
+			  menustate = MENU_JOYKBDMAP2;
+				menu_timeoutstate = MENU_JOYKBDMAP1;
+				break;
+		  }
+		  memset(&abm_edit_map, 0, sizeof(abm_edit_map));
+			input_advanced_save(abm_dev_num);
+		}
+
+		
+		int osd_cnt = code_capture_osd_count();
+    if (!abm_edit_map.input_codes[0] && !abm_edit_codes[osd_cnt] && (is_osd || is_enter || is_esc))
+		{
+			int exit_status = 0;
+      if (pressed && !abm_clear_timer && is_osd)
+			{
+			  abm_clear_timer = GetTimer(5000);
+			} else if (pressed && CheckTimer(abm_clear_timer) && is_osd) {
+        //User cleared
+				exit_status = 2;
+		  } else if (!pressed && abm_edit_codes[0]) {
+				if (is_enter)
+				  exit_status = 2;
+				else
+					exit_status = 1;
+			}
+
+			if (exit_status)
+			{
+			  end_code_capture();
+				if (exit_status == 2)
+			  {	
+				  memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+				  memset(abms, 0, sizeof(advancedButtonMap)*ADVANCED_MAP_MAX);
+					memset(&abm_edit_map, 0, sizeof(abm_edit_map));
+				}
+				abm_clear_timer = 0;
+			  menu_timeout = GetTimer(1000);
+			  OsdWrite(1);
+			  OsdWrite(2, exit_status == 2 ? "          Clearing" : "          Finishing");
+			  OsdWrite(3);
+			  OsdWrite(OsdGetSize() - 1);
+			  menustate = MENU_JOYKBDMAP2;
+				menu_timeoutstate = MENU_COMMON1;
+				break;
 			}
-			OsdWrite(OsdGetSize() - 1);
+
 		}
 
-		if (select || menu || get_map_finish() || get_map_cancel())
+		if (!pressed && is_captured)  
 		{
-			int clear = get_map_vid() && (menu || get_map_cancel());
-			finish_map_setting(clear);
-			menu_timeout = GetTimer(1000);
-			OsdWrite(1);
-			OsdWrite(2, clear ? "          Clearing" : "          Finishing");
-			OsdWrite(3);
+			if (!abm_edit_map.input_codes[0])
+			{
+				if (input_advanced_check_hotkeys(abm_edit_codes, sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0]), abm_dev_num))
+				{
+			    memcpy(abm_edit_map.input_codes, abm_edit_codes, sizeof(abm_edit_map.input_codes));
+			  } else {
+			    OsdWrite(1);
+					OsdWrite(2, "    Cannot remap Menu/F12!");
+					OsdWrite(3);
+					OsdWrite(OsdGetSize() - 1);
+					menu_timeout = GetTimer(2000);
+					menustate = MENU_JOYKBDMAP2;
+					menu_timeoutstate = MENU_JOYKBDMAP1;
+					break;
+				}
+		  } else {
+			  memcpy(abm_edit_map.output_codes, abm_edit_codes, sizeof(abm_edit_map.output_codes));
+			}
+			memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+		}
+		if (!abm_edit_map.input_codes[0])
+		{
+			char str[128] = {};
+		  if (abm_edit_codes[0])
+			  build_advanced_map_code_str(abm_edit_codes, sizeof(abm_edit_codes), str, sizeof(str), 14);
+
+			OsdWrite(1, "       Press button(s) ", 0, 0);
+			OsdWrite(2, "     or key(s) to change", 0, 0);
+      OsdWrite(3, str, 0, 0);
+			OsdWrite(4, "", 0, 0);
+
+			OsdWrite(OsdGetSize() - 1, " Enter \x16 Clear, Esc \x16 Finish", menusub == 0, 0);
+		} else {
+			if (device_is_keyboard(abm_dev_num))
+			{
+				OsdWrite(1, "     Press key(s) to map to", 0, 0);
+				OsdWrite(2, "        on a keyboard", 0, 0);
+			  char str[128] = {};
+		    if (abm_edit_codes[0])
+			    build_advanced_map_code_str(abm_edit_codes, sizeof(abm_edit_codes), str, sizeof(str), 14);
+				OsdWrite(3, str, 0, 0);
+
+			}
+			else
+			{
+				OsdWrite(1, "   Press button(s) to map to", 0, 0);
+				OsdWrite(2, "        on the same pad", 0, 0);
+				OsdWrite(3, "    or key(s) on a keyboard", 0, 0);
+			  char str[128] = {};
+		    if (abm_edit_codes[0])
+			    build_advanced_map_code_str(abm_edit_codes, sizeof(abm_edit_codes), str, sizeof(str), 14);
+				OsdWrite(4, str, 0, 0);
+			}
 			OsdWrite(OsdGetSize() - 1);
-			menustate = MENU_JOYKBDMAP2;
 		}
-		break;
+	}
+	break;
 
 	case MENU_JOYKBDMAP2:
 		if (CheckTimer(menu_timeout))
 		{
-			menustate = MENU_COMMON1;
+			memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+			menustate = menu_timeoutstate; 
 			menusub = 3;
 		}
 		break;
@@ -7151,6 +7410,437 @@ void HandleUI(void)
 		SelectFile("", 0, SCANO_CORES, MENU_CORE_FILE_SELECTED1, cp_MenuCancel);
 		break;
 
+		//Advanced remapping
+
+	case MENU_ADVANCED_MAP_LIST1:
+	{
+						OsdSetTitle("Advanced");
+						menu_parse_buttons();
+						menustate = MENU_ADVANCED_MAP_LIST2;
+						parentstate = MENU_ADVANCED_MAP_LIST1;
+						abm_dev_num = get_last_input_dev();
+						while(1)
+						{
+							if (!menusub) firstmenu = 0;
+							adjvisible = 0;
+
+							advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+							menumask = 0x1;
+							uint32_t menucnt = 1;
+							MenuWrite(0, " New                       \x16", menusub == menucnt++, 0);
+
+							int n = 1;
+							char bname[32] = {};
+							size_t map_cnt = 0;
+							for(size_t i = 0; i < ADVANCED_MAP_MAX; i++)
+							{
+								advancedButtonMap *abm = abms+i;
+								if (!abm->input_codes[0]) break;
+								map_cnt++;
+								int mapped_button_cnt = 0;
+								int first_map_idx = -1;
+								for (uint bn = 0; bn < sizeof(abm->button_mask)*8; bn++)
+								{
+									if (abm->button_mask & 1<<bn) 
+									{
+										mapped_button_cnt++;
+										if (first_map_idx == -1)
+											first_map_idx = bn;
+									}
+								}
+
+								for (uint bn = 0; bn < sizeof(abm->output_codes)/sizeof(abm->output_codes[0]); bn++)
+								{
+									if (abm->output_codes[bn]) 
+										mapped_button_cnt++;
+								}
+
+								bname[0] = 0;
+								if (mapped_button_cnt > 1)
+								{
+									sprintfz(bname, "(%d)", mapped_button_cnt);
+								} else {
+									if (abm->output_codes[0])
+										build_advanced_map_code_str(abm->output_codes, sizeof(abm->output_codes), bname, sizeof(bname));
+									else
+										menu_button_name(first_map_idx, bname, sizeof(bname));
+								}
+
+								char code_str[256] = {};
+								build_advanced_map_code_str(abm->input_codes, sizeof(abm->input_codes), code_str, sizeof(code_str));
+								sprintf(s, " %s->%s", code_str, bname);			
+								s[27] = '\x16';
+								s[28] = 0;
+								menumask |= 1<<(i+1);
+								MenuWrite(n++, s, menusub == i+1, 0);
+							}
+							MenuWrite(0, " New                       \x16", menusub == 0, map_cnt >= ADVANCED_MAP_MAX);
+							if (map_cnt >= ADVANCED_MAP_MAX)
+								menumask &= ~0x1;
+							for (; n < OsdGetSize(); n++) MenuWrite(n, "", 0, 0);
+							if (!adjvisible) break;
+							firstmenu += adjvisible;
+						}
+						break;
+				}
+
+			case MENU_ADVANCED_MAP_LIST2:
+				{
+					if (select)
+					{
+						advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+						memset(&abm_edit_map, 0, sizeof(abm_edit_map));
+						menustate = MENU_ADVANCED_MAP_EDIT1;
+						parentstate = MENU_ADVANCED_MAP_LIST1;
+						if (menusub == 0) {
+							//New, find suitable slot
+
+							for (int i = 0; i < ADVANCED_MAP_MAX; i++)
+								{
+									advancedButtonMap *abm = abms+i;
+									if (!abm->input_codes[0])
+									{
+										abm_edit_idx = i;
+										break;
+									}
+								}
+						} else {
+							abm_edit_idx = menusub -1;
+						}
+						menusub = 0;
+					}
+
+					if (left || back || menu)
+					{
+						menustate = MENU_COMMON1;
+						input_advanced_save(abm_dev_num);
+						parentstate = 0;
+						menusub = 3;
+					}
+					break;
+				}
+
+			case MENU_ADVANCED_MAP_EDIT1:
+				{
+					menustate = MENU_ADVANCED_MAP_EDIT2;
+					parentstate = MENU_ADVANCED_MAP_EDIT1;
+				  menumask = 0;
+					firstmenu = 0;
+					adjvisible = 0;
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					int mapped_button_cnt = 0;
+					int first_map_idx = -1;
+				  bool dev_kbd = device_is_keyboard(abm_dev_num);
+					for (uint bn = 0; bn < sizeof(edit_abm->button_mask)*8; bn++)
+					{
+						if (edit_abm->button_mask & 1<<bn) 
+						{
+							mapped_button_cnt++;
+							if (first_map_idx == -1)
+							{
+								first_map_idx = bn;
+							}
+						}
+					}
+
+					menu_parse_buttons();
+					char bname[32] = {};
+					if (mapped_button_cnt == 1 || mapped_button_cnt == 0)
+					{
+						
+						menu_button_name(mapped_button_cnt ? first_map_idx : -1, bname, sizeof(bname));
+					} else if (mapped_button_cnt) {
+						sprintfz(bname, "(%d)", mapped_button_cnt);
+					}
+
+				  bool keyboard_only = dev_kbd && (user_io_get_kbdemu() == EMU_NONE);
+
+					uint32_t n = 0;
+					char code_str[256] = {};
+
+					build_advanced_map_code_str(edit_abm->input_codes, sizeof(edit_abm->input_codes), code_str, sizeof(code_str));
+					snprintf(s, sizeof(s), " Input Hotkey(s) %-20s\x16",code_str);
+					MenuWrite(n, s, menusub == n, 0);
+				  menumask |= 1 << n++; 
+
+					code_str[0] = 0;
+					snprintf(s, sizeof(s), " Core Button(s): %-17s\x10 \x11", bname);
+					MenuWrite(n, s, keyboard_only ? 0 : menusub == n, keyboard_only ); 
+				  if(!keyboard_only) menumask |= 1 << n; 
+				  n++;
+
+					build_advanced_map_code_str(edit_abm->output_codes, sizeof(edit_abm->output_codes), code_str, sizeof(code_str));
+					snprintf(s, sizeof(s), " Output(s): %-20s\x16", code_str);
+					MenuWrite(n, s, menusub == n, 0);
+				  menumask |= 1 << n++; 
+
+					MenuWrite(n, " Delete", menusub == n, 0);
+				  menumask |= 1 << n++; 
+					MenuWrite(n, " Done", menusub == n, 0);
+				  menumask |= 1 << n++; 
+					for (int i = n; i < OsdGetSize(); i++) MenuWrite(i, "", 0, 0);
+					break;
+				}
+
+			case MENU_ADVANCED_MAP_EDIT2:
+				{
+					if (select || left || right)
+					{
+						menustate = MENU_ADVANCED_MAP_EDIT1;
+						advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+						advancedButtonMap *edit_abm = abms+abm_edit_idx;
+            char bname[32] = {0};
+						switch(menusub)
+							{
+								case 1:
+									{
+										int mapped_button_cnt = 0;
+										int first_map_idx = -1;
+										for (uint bn = 0; bn < sizeof(edit_abm->button_mask)*8; bn++)
+										{
+											if (edit_abm->button_mask & 1<<bn) 
+											{
+												mapped_button_cnt++;
+												if (first_map_idx == -1)
+												{
+													first_map_idx = bn;
+												}
+											}
+										}
+										if (select) 
+										{
+											menustate = MENU_ADVANCED_MAP_EDIT3;
+                      menusub = 0;
+										} else if (right && (mapped_button_cnt <= 1)) {
+											if (first_map_idx == -1) 
+												first_map_idx = 0;
+											else
+												first_map_idx++;
+											menu_button_name(first_map_idx, bname, sizeof(bname));
+                  	  while(!strncmp("-", bname, sizeof(bname)))
+                  	  {
+                  	    first_map_idx++;
+											  menu_button_name(first_map_idx, bname, sizeof(bname));
+                  	  }
+											if (first_map_idx-4 >= joy_bcount)
+											{
+												first_map_idx = 0;
+											}
+											edit_abm->button_mask = 1<<first_map_idx;
+										} else if (left && (mapped_button_cnt <= 1)) {
+											if (first_map_idx == -1) 
+												first_map_idx = 0;
+											else
+												first_map_idx--;
+											menu_button_name(first_map_idx, bname, sizeof(bname));
+                  	  while(!strncmp("-", bname, sizeof(bname)))
+                  	  {
+                  	    first_map_idx--;
+											  menu_button_name(first_map_idx, bname, sizeof(bname));
+                  	  }
+											if (first_map_idx < 0) first_map_idx=joy_bcount+3;
+											edit_abm->button_mask = 1<<first_map_idx;
+										}
+
+										break;
+									}
+								case 2: 
+									if (select) {
+										menustate = MENU_ADVANCED_MAP_KEYCAPTURE1;
+										memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+										start_code_capture(abm_dev_num);
+									}
+									break;
+								case 0:
+									if (select) {
+										menustate = MENU_ADVANCED_MAP_CAPTURE1;
+										memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+										start_code_capture(abm_dev_num);
+									}
+									break;
+								
+							case 3:
+									if (select)
+									{
+										menustate = MENU_ADVANCED_MAP_LIST1;
+										memset(edit_abm, 0, sizeof(advancedButtonMap));
+										//Don't allow 'holes' in the advanced map array
+										memmove(edit_abm, abms+(abm_edit_idx+1), sizeof(advancedButtonMap)*(ADVANCED_MAP_MAX-(abm_edit_idx+1)));
+										input_advanced_save(abm_dev_num);
+									}
+									break;
+								case 4:
+									if (select)
+									{
+										menustate = MENU_ADVANCED_MAP_LIST1;
+									}
+									break;
+							}
+					}
+
+					if (back || menu)
+					{
+						menustate = MENU_ADVANCED_MAP_LIST1;
+						menusub = 0;
+					}
+					break;
+				}
+			case MENU_ADVANCED_MAP_EDIT3:
+				{
+					menustate = MENU_ADVANCED_MAP_EDIT4;
+					parentstate = MENU_ADVANCED_MAP_EDIT3;
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					while (1) {
+						menumask = 0;
+						uint32_t n = 0;
+						if (!menusub) firstmenu = 0;
+						adjvisible = 0;
+						for (int i = 0; i < joy_bcount+4; i++)
+						{
+
+							char bname[32];
+							menu_button_name(i, bname, sizeof(bname));
+							if (!strcmp("-", bname)) continue;
+							bool b_used = edit_abm->button_mask & 1<<i;
+							sprintfz(s, "%s %s", b_used ? "*":" ", bname);	
+							MenuWrite(n, s, menusub == n, 0); 
+							menumask |= 1<<n;
+							n++;
+						}
+						if (!adjvisible) break;
+						firstmenu += adjvisible;
+					}
+					break;
+				}
+			case MENU_ADVANCED_MAP_EDIT4:
+				{
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					if (back || menu) 
+					{
+						menustate = MENU_ADVANCED_MAP_EDIT1;
+						menusub = 1;
+					} else if (select) {
+						menustate = MENU_ADVANCED_MAP_EDIT3;
+            uint32_t btn_cnt = 0;
+            for(int i = 0; i < joy_bcount+4; i++)
+            {
+              char bname[32];
+              menu_button_name(i, bname, sizeof(bname));
+              if (!strcmp("-", bname)) continue;
+              if (menusub == btn_cnt)
+              {
+                edit_abm->button_mask ^= 1<<i;
+                break;
+              }
+              btn_cnt++;
+            }
+					}
+					break;
+				}
+
+			case MENU_ADVANCED_MAP_CAPTURE1:
+			case MENU_ADVANCED_MAP_KEYCAPTURE1:
+				{
+					advancedButtonMap *abms = get_advanced_map_defs(abm_dev_num);
+					advancedButtonMap *edit_abm = abms+abm_edit_idx;
+					OsdSetTitle("Set Hotkey", 0);
+					for (int i = 0; i < 4; i++) OsdWrite(i, "", 0, 0);
+					OsdWrite(4, info_top, 0, 0);
+					if (menustate == MENU_ADVANCED_MAP_KEYCAPTURE1)
+					{
+					  infowrite(5, "Press key(s) on keyboard");
+					  infowrite(6, "or button(s) on joypad");
+					} else {
+					  infowrite(5, "Press Joypad button(s)");
+					  infowrite(6, "or Keyboard key(s)");
+					}
+					infowrite(7, "");
+
+					if (device_is_keyboard(abm_dev_num))
+					{
+					  infowrite(8, "Enter \x16 Clear");
+					} else {
+					  infowrite(8, "Menu-hold \x16 Clear");
+					}
+					OsdWrite(9, info_bottom, 0, 0);
+					char code_str[256] = {};
+					build_advanced_map_code_str(abm_edit_codes, sizeof(abm_edit_codes), code_str, sizeof(code_str), 14);
+					OsdWrite(10, code_str, 0, 0);
+
+					uint32_t captured_code = get_captured_code();
+					if (captured_code)
+					{
+						uint code_idx = 0;
+						bool is_captured = false;
+						bool pressed = (captured_code & 0x8000);
+						bool is_osd = (captured_code & 0x4000);
+						captured_code &= 0x3FF;
+						bool is_enter = captured_code == KEY_ENTER;
+
+				    if (!abm_edit_codes[1] && is_enter & !pressed)
+						{
+  
+								memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+								uint16_t *dest = (menustate == MENU_ADVANCED_MAP_KEYCAPTURE1) ? edit_abm->output_codes : edit_abm->input_codes;
+								size_t dsize = (menustate == MENU_ADVANCED_MAP_KEYCAPTURE1) ? sizeof(edit_abm->output_codes) : sizeof(edit_abm->input_codes);
+								memset(dest, 0, dsize);
+  							menustate = MENU_ADVANCED_MAP_EDIT1;
+								menusub = menustate == MENU_ADVANCED_MAP_KEYCAPTURE1 ? 2 : 0;
+								end_code_capture();
+								break;
+						}
+
+		        int osd_cnt = code_capture_osd_count();
+						if (is_osd && !abm_edit_codes[osd_cnt] && pressed)
+						{
+							if (!abm_clear_timer)
+							{
+                abm_clear_timer = GetTimer(5000);
+							} else if (CheckTimer(abm_clear_timer)) {
+							  abm_clear_timer = 0;
+								memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+								uint16_t *dest = (menustate == MENU_ADVANCED_MAP_KEYCAPTURE1) ? edit_abm->output_codes : edit_abm->input_codes;
+								size_t dsize = (menustate == MENU_ADVANCED_MAP_KEYCAPTURE1) ? sizeof(edit_abm->output_codes) : sizeof(edit_abm->input_codes);
+								memset(dest, 0, dsize);
+  							menustate = MENU_ADVANCED_MAP_EDIT1;
+								menusub = menustate == MENU_ADVANCED_MAP_KEYCAPTURE1 ? 2 : 0;
+								end_code_capture();
+								break;
+							}
+						}
+
+						while(abm_edit_codes[code_idx] && code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0]))
+					  {
+								if (abm_edit_codes[code_idx] == captured_code) is_captured = true;
+								code_idx++;
+						}
+						if (!is_captured && pressed && (code_idx < sizeof(abm_edit_codes)/sizeof(abm_edit_codes[0])))
+						{
+							abm_edit_codes[code_idx] = captured_code;
+						}
+						if (!pressed && is_captured)  
+						{
+							end_code_capture();
+					  	uint16_t *dest = (menustate == MENU_ADVANCED_MAP_KEYCAPTURE1) ? edit_abm->output_codes : edit_abm->input_codes;
+							size_t dsize = (menustate == MENU_ADVANCED_MAP_KEYCAPTURE1) ? sizeof(edit_abm->output_codes) : sizeof(edit_abm->input_codes);
+							memcpy(dest, abm_edit_codes, dsize); 
+							menustate = MENU_ADVANCED_MAP_EDIT1;
+						}
+
+					}
+					break;
+				}
+	case MENU_ADVANCED_MAP_CAPTURETIMEOUT:
+		  if (CheckTimer(menu_timeout))
+		  {
+			  memset(abm_edit_codes, 0, sizeof(abm_edit_codes));
+			  menustate = menu_timeoutstate; 
+		  }
+			break;
+
 		/******************************************************************/
 		/* we should never come here                                      */
 		/******************************************************************/
diff --git a/user_io.cpp b/user_io.cpp
index 4f108fe..bbce8b5 100644
--- a/user_io.cpp
+++ b/user_io.cpp
@@ -1735,23 +1735,22 @@ void user_io_r_analog_joystick(unsigned char joystick, char valueX, char valueY)
 	}
 }
 
-void user_io_digital_joystick(unsigned char joystick, uint64_t map, int newdir)
+void user_io_digital_joystick(unsigned char joystick, uint32_t map, int newdir)
 {
 	uint8_t joy = (joystick>1 || !joyswap) ? joystick : joystick ^ 1;
 	static int use32 = 0;
 	// primary button mappings are in 31:0, alternate mappings are in 64:32.
 	// take the logical OR to ensure a held button isn't overriden
 	// by other mapping being pressed
-	uint32_t bitmask = (uint32_t)(map) | (uint32_t)(map >> 32);
-	use32 |= bitmask >> 16;
+	use32 |= map >> 16;
 	spi_uio_cmd_cont((joy < 2) ? (UIO_JOYSTICK0 + joy) : (UIO_JOYSTICK2 + joy - 2));
-	spi_w(bitmask);
-	if(use32) spi_w(bitmask >> 16);
+	spi_w(map);
+	if(use32) spi_w(map >> 16);
 	DisableIO();
 
 	if (!is_minimig() && joy_transl == 1 && newdir)
 	{
-		user_io_l_analog_joystick(joystick, (bitmask & 2) ? 128 : (bitmask & 1) ? 127 : 0, (bitmask & 8) ? 128 : (bitmask & 4) ? 127 : 0);
+		user_io_l_analog_joystick(joystick, (map & 2) ? 128 : (map & 1) ? 127 : 0, (map & 8) ? 128 : (map & 4) ? 127 : 0);
 	}
 }
 
@@ -4088,7 +4087,7 @@ void user_io_kbd(uint16_t key, int press)
 				if (key == KEY_MENU) key = KEY_F12;
 				if (key != KEY_F12 || !block_F12)
 				{
-					if (osd_is_visible) menu_key_set(UPSTROKE | key);
+					/*if (osd_is_visible)*/ menu_key_set(UPSTROKE | key);
 
 					// these modifiers should be passed to core even if OSD is open or they will get stuck!
 					if (!osd_is_visible || key == KEY_LEFTALT || key == KEY_RIGHTALT || key == KEY_LEFTMETA || key == KEY_RIGHTMETA) send_keycode(key, press);
@@ -4101,7 +4100,7 @@ void user_io_kbd(uint16_t key, int press)
 				if (!osd_is_visible && !is_menu() && key == KEY_MENU && press == 3) open_joystick_setup();
 				else if ((has_menu() || osd_is_visible || (get_key_mod() & (LALT | RALT | RGUI | LGUI))) && (((key == KEY_F12) && (!is_f12_mod_needed() || (get_key_mod() & (RGUI | LGUI)))) || key == KEY_MENU))
 				{
-					block_F12 = 1;
+					//block_F12 = 1;
 					if (press == 1) menu_key_set(KEY_F12);
 				}
 				else if (osd_is_visible)
diff --git a/user_io.h b/user_io.h
index 69f04d0..5c31026 100644
--- a/user_io.h
+++ b/user_io.h
@@ -206,7 +206,7 @@ void user_io_mouse(unsigned char b, int16_t x, int16_t y, int16_t w);
 void user_io_kbd(uint16_t key, int press);
 char* user_io_create_config_name(int with_ver = 0);
 int user_io_get_joy_transl();
-void user_io_digital_joystick(unsigned char, uint64_t, int);
+void user_io_digital_joystick(unsigned char, uint32_t, int);
 void user_io_l_analog_joystick(unsigned char, char, char);
 void user_io_r_analog_joystick(unsigned char, char, char);
 void user_io_set_joyswap(int swap);
-- 
2.52.0

