From 3df02e631c5e2fb99b30cb5f8dd562c886bb02d6 Mon Sep 17 00:00:00 2001
From: Zakk <zakk@rsdio.com>
Date: Sun, 21 Feb 2021 16:56:00 -0500
Subject: [PATCH 2/2] Add support for more drive status commands (fixes MSU-MD
 track looping) Report CD_STAT_SEEK during CD_COMM_PLAY latency. Fixes audio
 delay in some games

Thanks to ekeeke for doing the work in Genesis-Plus-GX to use as reference.
---
 support/megacd/megacdd.cpp | 49 +++++++++++++++++++++++++++++++-------
 1 file changed, 40 insertions(+), 9 deletions(-)

diff --git a/support/megacd/megacdd.cpp b/support/megacd/megacdd.cpp
index 37ec919..3b25185 100644
--- a/support/megacd/megacdd.cpp
+++ b/support/megacd/megacdd.cpp
@@ -489,16 +489,47 @@ void cdd_t::CommandExec() {
 
 	switch (comm[0]) {
 	case CD_COMM_IDLE:
-		stat[0] = this->status;
-
-		if (stat[1] == 0x0f)
+		if (this->latency <= 3)
 		{
-			if (!this->latency)
+			stat[0] = this->status;
+			if (stat[1] == 0x0f)
 			{
-				stat[0] = this->status;
-				stat[1] = 0x2;
-				stat[2] = (cdd.index < this->toc.last) ? BCD(this->index + 1) >> 4 : 0xA;
-				stat[3] = (cdd.index < this->toc.last) ? BCD(this->index + 1) & 0xF : 0xA;
+				int lba = this->lba + 150;
+				LBAToMSF(lba, &msf);
+				stat[1] = 0x0;
+	                        stat[2] = BCD(msf.m) >> 4;
+				stat[3] = BCD(msf.m) & 0xF;
+				stat[4] = BCD(msf.s) >> 4;
+				stat[5] = BCD(msf.s) & 0xF;
+				stat[6] = BCD(msf.f) >> 4;
+				stat[7] = BCD(msf.f) & 0xF;
+				stat[8] = this->toc.tracks[this->index].type ? 0x04 : 0x00;
+
+				//stat[2] = (cdd.index < this->toc.last) ? BCD(this->index + 1) >> 4 : 0xA;
+				//stat[3] = (cdd.index < this->toc.last) ? BCD(this->index + 1) & 0xF : 0xA;
+			} else if (stat[1] == 0x00) {
+				int lba = this->lba + 150;
+				LBAToMSF(lba, &msf);
+                                stat[2] = BCD(msf.m) >> 4;
+                                stat[3] = BCD(msf.m) & 0xF;
+                                stat[4] = BCD(msf.s) >> 4;
+                                stat[5] = BCD(msf.s) & 0xF;
+                                stat[6] = BCD(msf.f) >> 4;
+                                stat[7] = BCD(msf.f) & 0xF;
+                                stat[8] = this->toc.tracks[this->index].type ? 0x04 : 0x00;
+			} else if (stat[1] == 0x01) {
+				int lba = abs(this->lba - this->toc.tracks[this->index].start);
+				LBAToMSF(lba,&msf);
+                                stat[2] = BCD(msf.m) >> 4;
+                                stat[3] = BCD(msf.m) & 0xF;
+                                stat[4] = BCD(msf.s) >> 4;
+                                stat[5] = BCD(msf.s) & 0xF;
+                                stat[6] = BCD(msf.f) >> 4;
+                                stat[7] = BCD(msf.f) & 0xF;
+                                stat[8] = this->toc.tracks[this->index].type ? 0x04 : 0x00;
+			} else if (stat[1] == 0x02) {
+                               stat[2] = (cdd.index < this->toc.last) ? BCD(this->index + 1) >> 4 : 0xA;
+                               stat[3] = (cdd.index < this->toc.last) ? BCD(this->index + 1) & 0xF : 0xA;
 			}
 		}
 
@@ -687,7 +718,7 @@ void cdd_t::CommandExec() {
 
 		this->status = CD_STAT_PLAY;
 
-		stat[0] = this->status;
+		stat[0] = CD_STAT_SEEK; 
 		stat[1] = 0xf;
 		stat[2] = 0;
 		stat[3] = 0;
-- 
2.30.1

